<h1 id="getting-a-new-query">Getting a New Query</h1>
<p>A query builder is a stateful, transient object. That means that if you want to execute two different queries, you need two separate instances of QueryBuilder.</p>
<pre><code class="language-javascript">// This will cause you pain and grief...

var user = query.from( &quot;users&quot; )
  .where( &quot;username&quot;, rc.username )
  .first();

var posts = query.from( &quot;posts&quot; ).get();
// This will error because username is not a column in posts.</code></pre>
<p>As such, be careful when injecting QueryBuilder in to a component. If the component is a singleton, you will need to create the QueryBuilder inline or use a provider. This applies to ColdBox handlers as well.</p>
<pre><code class="language-javascript">component {

    property name=&quot;query&quot; inject=&quot;QueryBuilder@qb&quot;;

    function create( event, rc, prc ) {
        query.table( &quot;posts&quot; )
            .where( &quot;id&quot;, rc.id )
            .update( event.getOnly( [ &quot;body&quot; ] ) );
    }

}</code></pre>
<p>While the above may seem innoculous, it can run in to issues as multiple requests come in to your application. Each request is sharing the same query builder instance and subsequent requests will have unintended results as the where clause keeps growing request after request.</p>
<p>The solution is to either create the QueryBuilder inline, ensuring that each request has its own query to execute:</p>
<pre><code class="language-javascript">component {

    function create( event, rc, prc ) {
        getInstance( &quot;QueryBuilder@qb&quot; )
            .table( &quot;posts&quot; )
            .where( &quot;id&quot;, rc.id )
            .update( event.getOnly( [ &quot;body&quot; ] ) );
    }

}</code></pre>
<p>Or to use a WireBox provider to create a new query each time it is accessed:</p>
<pre><code class="language-javascript">component {

    property name=&quot;query&quot; inject=&quot;provider:QueryBuilder@qb&quot;;

    function create( event, rc, prc ) {
        query.table( &quot;posts&quot; )
            .where( &quot;id&quot;, rc.id )
            .update( event.getOnly( [ &quot;body&quot; ] ) );
    }

}</code></pre>
<p>One caveat when using a WireBox Provider: WireBox Providers proxy methods on to a new instance of the provided mapping on all methods except get. get is a method on the Provider itself. If you call get as the first method on a Provider it will return a new instance of QueryBuilder, not execute the query. In those (rare) cases you will need to call query.get().get().</p>
<h2 id="newquery">newQuery</h2>
<p>Once you have access to a QueryBuilder instance, you can create a new query using the same datasource, utils, returnFormat, paginationCollector, columnFormatter, and defaultOptions as the current QueryBuilder instance.</p>
<pre><code class="language-javascript">// This will cause you pain and grief...

var user = query.from( &quot;users&quot; )
  .where( &quot;username&quot;, rc.username )
  .first();

var posts = query.newQuery().from( &quot;posts&quot; ).get();
// This will work as we expect it to.</code></pre>
