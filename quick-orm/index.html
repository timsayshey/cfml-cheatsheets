<html>
  <head>
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700|Droid+Sans:700" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="../common.css">
    <link rel="stylesheet" href="../common/lib/atom-one-light.css">
    <link rel="stylesheet" href="./quick-orm.css">
  </head>
  <body>
    <input type="checkbox" id="showPreview"/>
    <div class="first-side">
      <div class="cutter">
<div class="cut cut-top-left">&nbsp;</div>
<div class="cut cut-bottom-left">&nbsp;</div>
<div class="cut cut-top-right">&nbsp;</div>
<div class="cut cut-bottom-right">&nbsp;</div>
</div>
<header>
    <div class="home-button no-print">
        <a href="../" title="back to home cheat Sheet"><i class="material-icons">home</i></a>
        <label for="showPreview"><i class="material-icons">visibility</i></label>
    </div>
    <div class="header-center">
        <div class="description-content">
            <div class="title">Quick ORM cheat sheet</div>
            <div class="sub-title">sous titre, une description.</div>
        </div>

        <div class="logo-container">
            <img src="../assets/images/quick-orm.png">
        </div>
    </div>
    <div class="logo-category no-print">
        <i class="material-icons" onclick="printLarge()">print</i>
    </div>
</header>



      <main>
        <div class="column1">
          <h1 id="common-table-expressions-ie-ctes">Common Table Expressions (i.e. CTEs)</h1>
<p>Common Table Expressions (CTEs) allow you to create re-usable temporal result sets.</p>
<h2 id="with">with</h2>
<p>You can build a CTE using a function:</p>
<pre><code class="language-javascript">// qb
query.with( &quot;UserCTE&quot;, function ( q ) {
        q
            .select( [ &quot;fName as firstName&quot;, &quot;lName as lastName&quot; ] )
            .from( &quot;users&quot; )
            .where( &quot;disabled&quot;, 0 );
    } )
    .from( &quot;UserCTE&quot; )
    .get();</code></pre>
<h2 id="withrecursive">withRecursive</h2>
<pre><code class="language-javascript">query
.withRecursive( &quot;Hierarchy&quot;, function ( q ) {
    q.select( [ &quot;Id&quot;, &quot;ParentId&quot;, &quot;Name&quot;, q.raw( &quot;0 AS [Generation]&quot; ) ] )
        .from( &quot;Sample&quot; )
        .whereNull( &quot;ParentId&quot; )
        // use recursion to join the child rows to their parents
        .unionAll( function ( q ) {
            q.select( [
                    &quot;child.Id&quot;,
                    &quot;child.ParentId&quot;,
                    &quot;child.Name&quot;,
                    q.raw( &quot;[parent].[Generation] + 1&quot; )
                ] )
                .from( &quot;Sample as child&quot; )
                .join( &quot;Hierarchy as parent&quot;, &quot;child.ParentId&quot;, &quot;parent.Id&quot; );
        } );
    }, [ &quot;Id&quot;, &quot;ParentId&quot;, &quot;Name&quot;, &quot;Generation&quot; ] )
    .from( &quot;Hierarchy&quot; )
    .get();</code></pre>

          <h1 id="from">From</h1>
<h2 id="from-1">from</h2>
<p>Used to set the base table for the query.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; );</code></pre>
<p>You can optionally specify an alias for the table.</p>
<pre><code class="language-javascript">query.from( &quot;users as u&quot; );</code></pre>
<h2 id="table">table</h2>
<p>An alias for from where you like how calling table looks.</p>
<pre><code class="language-javascript">query.table( &quot;users&quot; ).insert( { &quot;name&quot; = &quot;jon&quot; } );</code></pre>
<h2 id="fromraw">fromRaw</h2>
<p>Sometimes you need more control over your from clause in order to add grammar specific instructions, such as adding SQL Server table hints to your queries.</p>
<pre><code class="language-javascript">query.fromRaw( &quot;[users] u (nolock)&quot; ).get();</code></pre>
<p>Failure to properly escape your table names may result in SQL errors.</p>
<pre><code class="language-javascript">query.fromRaw(
    &quot;dbo.generateDateTable(?, ?, ?) as dt&quot;,
    [ &quot;2017-01-01&quot;, &quot;2017-12-31&quot;, &quot;m&quot; ]
).get();</code></pre>
<h2 id="fromsub">fromSub</h2>
<p>Complex queries often contain derived tables. Derived tables are essentially a temporal table defined as a subquery in the from statement.</p>
<pre><code class="language-javascript">query.select( [ &quot;firstName&quot;, &quot;lastName&quot; ] )
    .fromSub( &quot;legalUsers&quot;, function ( q ) {
        q.select( [ &quot;lName as lastName&quot;, &quot;fName as firstName&quot; ] )
            .from( &quot;users&quot; )
            .where( &quot;age&quot;, &quot;&gt;=&quot;, 21 )
        ;
    } )
    .orderBy( &quot;lastName&quot; )
    .get()</code></pre>

          <h1 id="group-by-and-having">Group By and Having</h1>
<h2 id="groupby">groupBy</h2>
<p>Passing a single string will group by that one column.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .groupBy( &quot;country&quot; );</code></pre>
<p>You can also pass a list of column names.  A single comma  &quot;,&quot;  will be used as the delimiter.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .groupBy( &quot;country,city&quot; );</code></pre>
<p>An array of column names can be provided.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .groupBy( [ &quot;country&quot;, &quot;city&quot; ] );</code></pre>
<p>Calling groupBy multiple times will to the current groups.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .groupBy( &quot;country&quot; )
    .groupBy( &quot;city&quot; );</code></pre>
<p>An <a href="raw-expressions.md">Expression</a> can be passed in place of a column.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .groupBy( query.raw( &quot;DATE(created_at)&quot; ) );</code></pre>
<h2 id="having">having</h2>
<p>Adds a having clause to a query.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .groupBy( &quot;email&quot; )
    .having( &quot;email&quot;, &quot;&gt;&quot;, 1 );</code></pre>
<p>`Expressions can be used in place of the column or the value.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .groupBy( &quot;email&quot; )
    .having( query.raw( &quot;COUNT(email)&quot; ), &quot;&gt;&quot;, 1 );</code></pre>

          <h1 id="joins">Joins</h1>
<p>Join clauses range from simple to complex including joining complete subqueries on multiple conditions. qb has your back with all of these use cases.</p>
<h2 id="join">join</h2>
<p>Applies a join to the query. The simplest join is to a table based on two columns:</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .join( &quot;posts&quot;, &quot;users.id&quot;, &quot;=&quot;, &quot;posts.author_id&quot; );</code></pre>
<p>When doing a simple join using = as the operator, you can omit it and pass just the column names:</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .join( &quot;posts&quot;, &quot;users.id&quot;, &quot;posts.author_id&quot; );</code></pre>
<p>Expressions are also supported as the table argument:</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .join( query.raw( &quot;posts (nolock)&quot; ), &quot;users.id&quot;, &quot;=&quot;, &quot;posts.author_id&quot; );</code></pre>
<p>Using raw will most likely tie your code to a specific database, so think carefully before using the raw method if you want your project to be database agnostic.</p>
<p>When you need to specify more clauses to join, you can pass a function as the second argument:</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .join( &quot;posts&quot;, function( j ) {
        j.on( &quot;users.id&quot;, &quot;=&quot;, &quot;posts.author_id&quot; );
        j.on( &quot;users.prefix&quot;, &quot;=&quot;, &quot;posts.prefix&quot; );
    } );</code></pre>
<p>You can specify where clauses in your joins as well.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .join( &quot;posts&quot;, function( j ) {
        j.on( &quot;users.id&quot;, &quot;=&quot;, &quot;posts.author_id&quot; );
        j.whereNotNull( &quot;posts.published_date&quot; );
    } );</code></pre>
<p>Conditions inside a join clause can be grouped using a function.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .join( &quot;posts&quot;, function( j ) {
        j.on( function( j1 ) {
            j1.on( &quot;users.id&quot;, &quot;posts.author_id&quot; )
                .orOn( &quot;users.id&quot;, &quot;posts.reviewer_id&quot; );
        } );
        j.whereNotNull( &quot;posts.published_date&quot; );
    } );</code></pre>
<p>A preconfigured JoinClause can also be passed to the join function.</p>
<pre><code class="language-javascript">var j = query.newJoin( &quot;contacts&quot; )
    .on( &quot;users.id&quot;, &quot;posts.author_id&quot; );
    query.from( &quot;users&quot; ).join( j );</code></pre>
<h2 id="joinwhere">joinWhere</h2>
<p>Adds a join to another table based on a WHERE clause instead of an ON clause.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .joinWhere( &quot;contacts&quot;, &quot;contacts.balance&quot;, &quot;&lt;&quot;, 100 );</code></pre>
<p>For complex joins, a function can be passed to first.</p>
<h2 id="joinraw">joinRaw</h2>
<p>Uses the raw SQL provided to as the table for the join clause.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .joinRaw( &quot;posts (nolock)&quot;, &quot;users.id&quot;, &quot;posts.author_id&quot; );</code></pre>
<p>Using joinRaw will most likely tie your code to a specific database</p>
<h2 id="joinsub">joinSub</h2>
<p>Adds a join to a derived table. All the functionality of the join method applies to constrain the query.</p>
<pre><code class="language-javascript">var sub = query.newQuery()
    .select( &quot;id&quot; )
    .from( &quot;contacts&quot; )
    .whereNotIn( &quot;id&quot;, [ 1, 2, 3 ] );
    query.from( &quot;users as u&quot; )
    .joinSub( &quot;c&quot;, sub, &quot;u.id&quot;, &quot;=&quot;, &quot;c.id&quot; );</code></pre>
<p>Alternatively, a function may be used to define the derived table:</p>
<pre><code class="language-javascript">query.from( &quot;users as u&quot; )
    .joinSub( &quot;c&quot;, function ( q ) {
        q.select( &quot;id&quot; )
            .from( &quot;contacts&quot; )
            .whereNotIn( &quot;id&quot;, [ 1, 2, 3 ] );
    }, &quot;u.id&quot;, &quot;=&quot;, &quot;c.id&quot; );</code></pre>
<p>Complex join conditions are also possible by passing a function as the third parameter:</p>
<pre><code class="language-javascript">query.from( &quot;users as u&quot; )
    .joinSub( &quot;c&quot;, function ( q ) {
        q.select( &quot;id&quot; )
            .from( &quot;contacts&quot; )
            .whereNotIn( &quot;id&quot;, [ 1, 2, 3 ] );
    }, function( j ) {
        j.on( &quot;u.id&quot;, &quot;c.id&quot; );
        j.on( &quot;u.type&quot;, &quot;c.type&quot; );
    } );</code></pre>
<h2 id="leftjoin">leftJoin</h2>
<pre><code class="language-javascript">query.from( &quot;posts&quot; )
    .leftJoin( &quot;users&quot;, &quot;users.id&quot;, &quot;posts.author_id&quot; );</code></pre>
<h2 id="leftjoinraw">leftJoinRaw</h2>
<p>Uses the raw SQL provided to as the table for the left join clause. All the other functionality of leftJoinRaw matches the join method.</p>
<pre><code class="language-javascript">query.from( &quot;posts&quot; )
    .leftJoinRaw( &quot;users (nolock)&quot;, &quot;users.id&quot;, &quot;posts.author_id&quot; );</code></pre>
<h2 id="leftjoinsub">leftJoinSub</h2>
<p>Adds a left join to a derived table.</p>
<pre><code class="language-javascript">var sub = query.newQuery()
    .select( &quot;id&quot; )
    .from( &quot;contacts&quot; )
    .whereNotIn( &quot;id&quot;, [ 1, 2, 3 ] );
    query.from( &quot;users as u&quot; )
    .leftJoinSub( &quot;c&quot;, sub, &quot;u.id&quot;, &quot;=&quot;, &quot;c.id&quot; );</code></pre>
<h2 id="rightjoin">rightJoin</h2>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .rightJoin( &quot;posts&quot;, &quot;users.id&quot;, &quot;posts.author_id&quot; );</code></pre>
<h2 id="rightjoinraw">rightJoinRaw</h2>
<p>Uses the raw SQL provided to as the table for the right join clause.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .rightJoinRaw( &quot;posts (nolock)&quot;, &quot;users.id&quot;, &quot;posts.author_id&quot; );</code></pre>
<p>Using rightJoinRaw will most likely tie your code to a specific database.</p>
<h2 id="rightjoinsub">rightJoinSub</h2>
<p>Adds a right join to a derived table.</p>
<pre><code class="language-javascript">var sub = query.newQuery()
    .select( &quot;id&quot; )
    .from( &quot;contacts&quot; )
    .whereNotIn( &quot;id&quot;, [ 1, 2, 3 ] );
    query.from( &quot;users as u&quot; )
    .rightJoinSub( &quot;c&quot;, sub, &quot;u.id&quot;, &quot;=&quot;, &quot;c.id&quot; );</code></pre>
<h2 id="crossjoin">crossJoin</h2>
<pre><code class="language-javascript">query.from( &quot;users&quot; ).crossJoin( &quot;posts&quot; );</code></pre>
<h2 id="crossjoinraw">crossJoinRaw</h2>
<p>Uses the raw SQL provided to as the table for the cross join clause. Cross joins cannot be further constrained with on or where clauses.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; ).crossJoinRaw( &quot;posts (nolock)&quot; );</code></pre>
<p>Using crossJoinRaw will most likely tie your code to a specific database, so think carefully before using the crossJoinRaw method if you want your project to be database agnostic.</p>
<h2 id="crossjoinsub">crossJoinSub</h2>
<p>Adds a cross join to a derived table. The derived table can be defined using a QueryBuilder instance or a function just as with <a href="https://qb.ortusbooks.com/query-builder/building-queries/joins#joinsub">joinSub</a>. Cross joins cannot be constrained, however.</p>
<pre><code class="language-javascript">var sub = query.newQuery()
    .select( &quot;id&quot; )
    .from( &quot;contacts&quot; )
    .whereNotIn( &quot;id&quot;, [ 1, 2, 3 ] );
    query.from( &quot;users as u&quot; ).crossJoinSub( &quot;c&quot;, sub );</code></pre>
<h2 id="newjoin">newJoin</h2>
<pre><code class="language-javascript">var j = query.newJoin( &quot;contacts&quot; )
    .on( &quot;users.id&quot;, &quot;posts.author_id&quot; );
    query.from( &quot;users&quot; ).join( j );</code></pre>
<pre><code class="language-javascript">// This is still an inner join because
// the JoinClause is an inner join
var j = query.newJoin( &quot;contacts&quot;, &quot;inner&quot; )
    .on( &quot;users.id&quot;, &quot;posts.author_id&quot; );
    query.from( &quot;users&quot; ).leftJoin( j );</code></pre>
<h2 id="joinclause">JoinClause</h2>
<p>A JoinClause is a specialized version of a QueryBuilder. You may call on or orOn to constrain the JoinClause. You may also call any <a href="wheres.md">where</a> methods.</p>
<h3 id="on">on</h3>
<p>Applies a join condition to the JoinClause. An alias for whereColumn.</p>
<pre><code class="language-javascript">var j = query.newJoin( &quot;contacts&quot; )
    .on( &quot;users.id&quot;, &quot;posts.author_id&quot; );
    query.from( &quot;users&quot; ).join( j );</code></pre>
<h3 id="oron">orOn</h3>
<p>Applies a join condition to the JoinClause using an or combinator. An alias for orWhereColumn.</p>
<pre><code class="language-javascript">var j = query.newJoin( &quot;contacts&quot; )
    .on( &quot;users.id&quot;, &quot;posts.author_id&quot; )
    .orOn( &quot;users.id&quot;, &quot;posts.reviewer_id&quot; );
    query.from( &quot;users&quot; ).join( j );</code></pre>
<h2 id="preventing-duplicate-joins">Preventing Duplicate Joins</h2>
<p>You can optionally configure qb to ignore duplicate joins.</p>
<pre><code class="language-javascript">moduleSettings = {
    &quot;qb&quot;: {
         &quot;preventDuplicateJoins&quot;: true
    }
};</code></pre>

        </div>
        <div class="column2">
          <h1 id="order-by">Order By</h1>
<p>The orderBy method seems simple but has a lot of depth depending on the type of arguments you pass in.</p>
<p>Calling orderBy multiple times appends to the order list.</p>
<h2 id="order-by-string">Order By (String)</h2>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .orderBy( &quot;email&quot; );</code></pre>
<p>Calling orderBy multiple times will append to the order list.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .orderBy( &quot;email&quot; )
    .orderBy( &quot;username&quot;, &quot;desc&quot; );</code></pre>
<p>You can also provide an <a href="raw-expressions.md">Expression</a>.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .orderBy( query.raw( &quot;DATE(created_at)&quot; ) );</code></pre>
<h2 id="order-by-list">Order By (List)</h2>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .orderBy( &quot;email|asc,username&quot;, &quot;desc&quot; );</code></pre>
<h2 id="order-by-array-of-strings">Order By (Array of Strings)</h2>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .orderBy( [ &quot;email|asc&quot;, &quot;username&quot; ], &quot;desc&quot; );</code></pre>
<h2 id="order-by-array-of-structs">Order By (Array of Structs)</h2>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .orderBy( [
        { &quot;column&quot;: &quot;email&quot;, &quot;direction&quot;: &quot;asc&quot; },
        &quot;username&quot;
    ], &quot;desc&quot; );</code></pre>
<h2 id="order-by-subquery">Order By (Subquery)</h2>
<p>You can order with a subquery using either a function or a QueryBuilder instance.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .orderBy( function( q ) {
        q.selectRaw( &quot;MAX(created_date)&quot; )
            .from( &quot;logins&quot; )
            .whereColumn( &quot;users.id&quot;, &quot;logins.user_id&quot; );
    } );</code></pre>
<h2 id="order-by-raw">Order By Raw</h2>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .orderByRaw( &quot;CASE WHEN status = ? THEN 1 ELSE 0 END DESC&quot;, [ 1 ] );</code></pre>
<h2 id="clearorders">clearOrders</h2>
<p>Clears the currently configured orders for the query.  Usually used by downstream libraries like <a href="https://quick.ortusbooks.com/">Quick</a>.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .orderBy( &quot;email&quot; )
    .clearOrders();</code></pre>
<h2 id="reorder">reorder</h2>
<p>Clears the currently configured orders for the query and sets the new orders passed in.  Any valid argument to <a href="ordering-grouping-and-limit.md">orderBy</a> can be passed here.  Usually used by downstream libraries like <a href="https://quick.ortusbooks.com/">Quick</a>.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .orderBy( &quot;email&quot; )
    .reorder( &quot;username&quot; );</code></pre>

          <h1 id="query-parameters-and-bindings">Query Parameters and Bindings</h1>
<h2 id="custom-parameter-types">Custom Parameter Types</h2>
<p>When passing a parameter to qb, it will infer the sql type to be used.  If you pass a number, CF_SQL_NUMERIC will be used. If it is a date, CF_SQL_TIMESTAMP, and so forth. If you need more control, you can pass a struct with the parameters you would pass to <a href="https://cfdocs.org/cfqueryparam">cfqueryparam</a>.</p>
<p>You can pass include any parameters you would use with <a href="https://cfdocs.org/cfqueryparam">cfqueryparam</a> including null, list, etc.  This applies anywhere parameters are used including where, update, and insert methods.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .where( &quot;id&quot;, &quot;=&quot;, { value = 18, cfsqltype = &quot;CF_SQL_VARCHAR&quot; } );</code></pre>
<p>This can be used when inserting or updating records as well.</p>
<pre><code class="language-javascript">query.table( &quot;users&quot; )
    .insert( {
        &quot;id&quot; = { value 1, cfsqltype = &quot;CF_SQL_VARCHAR&quot; },
        &quot;age&quot; = 18,
        &quot;updatedDate&quot; = { value = now(), cfsqltype = &quot;CF_SQL_DATE&quot; }
    } );</code></pre>
<h3 id="strict-date-detection">Strict Date Detection</h3>
<p>By default, qb will try to determine if a variable is a date using the built-in isDate function.</p>
<pre><code class="language-javascript">moduleSettings = {
    &quot;qb&quot;: {
        &quot;strictDateDetection&quot;: true
    }
};</code></pre>
<h3 id="numeric-sql-type">Numeric SQL Type</h3>
<p>By default, qb will use the CF_SQL_NUMERIC SQL type when it detects a numeric binding.</p>
<pre><code class="language-javascript">moduleSettings = {
    &quot;qb&quot;: {
        &quot;numericSQLType&quot;: &quot;CF_SQL_INTEGER&quot;
    }
};</code></pre>
<h2 id="bindings">Bindings</h2>
<p>Bindings are the values that will be sent as parameters to a prepared SQL statement.</p>
<h3 id="getbindings">getBindings</h3>
<p>This method returns the current bindings in order to be used for the query.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .join( &quot;logins&quot;, function( j ) {
        j.on( &quot;users.id&quot;, &quot;logins.user_id&quot; );
        j.where( &quot;logins.created_date&quot;, &quot;&gt;&quot;, dateAdd( &quot;m&quot;, -1, &quot;01 Jun 2019&quot; ) );
    } )
    .where( &quot;active&quot;, 1 );</code></pre>
<p>You can also retrieve the bindings associated to their corresponding types.</p>
<h3 id="getrawbindings">getRawBindings</h3>
<p>This method returns the current bindings  to be used for the query associated to their corresponding types.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .join( &quot;logins&quot;, function( j ) {
        j.on( &quot;users.id&quot;, &quot;logins.user_id&quot; );
        j.where( &quot;logins.created_date&quot;, &quot;&gt;&quot;, dateAdd( &quot;m&quot;, -1, &quot;01 Jun 2019&quot; ) );
    } )
    .where( &quot;active&quot;, 1 );</code></pre>

          <h1 id="raw-expressions">Raw Expressions</h1>
<p>Raw expressions are the qb escape hatch.</p>
<h2 id="raw">raw</h2>
<p>The sql snippet passed to raw is not processed by qb at all.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; ).select( query.raw( &quot;MAX(created_date)&quot; ) );</code></pre>

          <h1 id="limit-offset-and-pagination">Limit, Offset, and Pagination</h1>
<h2 id="limit">limit</h2>
<p>Sets the limit value for the query.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .limit( 5 );</code></pre>
<h2 id="take">take</h2>
<p>Sets the limit value for the query.  Alias for <a href="limit-offset-and-pagination.md#limit">limit</a>.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .take( 5 );</code></pre>
<h2 id="offset">offset</h2>
<p>Sets the offset value for the query.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .offset( 25 );</code></pre>
<h2 id="forpage">forPage</h2>
<p>Helper method to calculate the limit and offset given a page number and count per page.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .forPage( 3, 15 );</code></pre>
<h2 id="simplepaginate--paginate">simplePaginate &amp; paginate</h2>
<p>This method combines forPage, count, and get to create a pagination struct alongside the results. Information on the simplePaginate or paginate methods, including custom pagination collectors, can be found in the <a href="../executing-queries/retrieving-results.md#paginate">Retreiving Results</a> section of the documentation.</p>

        </div>
        <div class="column2">
          <h1 id="selects">Selects</h1>
<h2 id="select">select</h2>
<p>If you pass no columns to this method, it will default to &quot;*&quot;.</p>
<pre><code class="language-javascript">.select( [ &quot;fname AS firstName&quot;, &quot;age&quot; ] ).from( &quot;users&quot; )</code></pre>
<h2 id="distinct">distinct</h2>
<p>Calling distinct will cause the query to be executed with the DISTINCT keyword.</p>
<pre><code class="language-javascript">.select( &quot;username&quot; ).distinct().from( &quot;users&quot; )</code></pre>
<h2 id="addselect">addSelect</h2>
<p>This method adds the columns passed to it to the currently selected columns.</p>
<pre><code class="language-javascript">.addSelect( [ &quot;fname AS firstName&quot;, &quot;age&quot; ] ).from( &quot;users&quot; )</code></pre>
<h2 id="selectraw">selectRaw</h2>
<p>A shortcut to use a raw expression in the select clause.</p>
<pre><code class="language-javascript">.selectRaw( &quot;YEAR(birthdate) AS birth_year&quot; ).from( &quot;users&quot; )</code></pre>
<h2 id="subselect">subSelect</h2>
<p>The subselect is added to the other already selected columns.</p>
<pre><code class="language-javascript">.subSelect( &quot;last_login_date&quot;, ( q ) =&gt; {
  q.selectRaw( &quot;MAX(created_date)&quot; ).from( &quot;logins&quot; )
} ) ).from( &quot;users&quot; )</code></pre>
<h2 id="clearselect">clearSelect</h2>
<p>Clears out the selected columns for a query along with any configured select bindings.</p>
<pre><code class="language-javascript">.from( &quot;users&quot; )
    .select( [ &quot;fname AS firstName&quot;, &quot;age&quot; ] )
    .clearSelect()</code></pre>
<h2 id="reselect">reselect</h2>
<p>Clears out the selected columns for a query along with any configured select bindings.</p>
<pre><code class="language-javascript">.from( &quot;users&quot; )
    .select( [ &quot;fname AS firstName&quot;, &quot;age&quot; ] )
    .reselect( &quot;username&quot; )</code></pre>
<h2 id="reselectraw">reselectRaw</h2>
<p>Clears out the selected columns.</p>
<pre><code class="language-javascript">.from( &quot;users&quot; ).select( [ &quot;fname AS firstName&quot;, &quot;age&quot; ] )
    .reselectRaw( &quot;YEAR(birthdate) AS birth_year&quot; )</code></pre>

          <h1 id="unions">Unions</h1>
<p>The query builder also lets you create union statements on your queries using either UNION or UNION ALL strategies.</p>
<h2 id="union">union</h2>
<p>Adds a UNION statement to the query.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .select( &quot;name&quot; )
    .where( &quot;id&quot;, 1 )
    .union( function ( q ) {
        q.from( &quot;users&quot; )
            .select( &quot;name&quot; )
            .where( &quot;id&quot;, 2 );
    } );</code></pre>
<p>Adding multiple union statements will append it to the query.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .select( &quot;name&quot; )
    .where( &quot;id&quot;, 1 )
    .union( function ( q ) {
        q.from( &quot;users&quot; )
            .select( &quot;name&quot; )
            .where( &quot;id&quot;, 2 );
    } )
    .union( function ( q ) {
        q.from( &quot;users&quot; )
            .select(&quot;name&quot;)
            .where( &quot;id&quot;, 3 );
    } );</code></pre>
<p>It can also add union queries as QueryBuilder instances.</p>
<pre><code class="language-javascript">var q1 = query.newQuery()
    .from( &quot;users&quot; )
    .select( &quot;name&quot; )
    .where( &quot;id&quot;, 2 );

var q2 = query.newQuery()
    .from( &quot;users&quot; )
    .select( &quot;name&quot; )
    .where( &quot;id&quot;, 3 );

query.from( &quot;users&quot; )
    .select( &quot;name&quot; )
    .where( &quot;id&quot;, 1 )
    .union( q1 )
    .union( q2 );</code></pre>
<h2 id="unionall">unionAll</h2>
<p>Adds a UNION ALL statement to the query.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .select( &quot;name&quot; )
    .where( &quot;id&quot;, 1 )
    .unionAll( function( q ) {
        q.from( &quot;users&quot; )
            .select( &quot;name&quot; )
            .where( &quot;id&quot;, 2 );
     } );</code></pre>
<p>Adding multiple unionAll statements will append it to the query.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .select( &quot;name&quot; )
    .where( &quot;id&quot;, 1 )
    .unionAll( function( q ) {
        q.from( &quot;users&quot; )
            .select( &quot;name&quot; )
            .where( &quot;id&quot;, 2 );
     } )
    .unionAll( function( q ) {
        q.from( &quot;users&quot; )
            .select( &quot;name&quot; )
            .where( &quot;id&quot;, 3 );
     } );</code></pre>
<p>It can also add union queries as QueryBuilder instances.</p>
<pre><code class="language-javascript">var q1 = query.newQuery()
    .from( &quot;users&quot; )
    .select( &quot;name&quot; )
    .where( &quot;id&quot;, 2 );

var q2 = query.newQuery()
    .from( &quot;users&quot; )
    .select( &quot;name&quot; )
    .where( &quot;id&quot;, 3 );

query.from( &quot;users&quot; )
    .select( &quot;name&quot; )
    .where( &quot;id&quot;, 1 )
    .unionAll( q1 )
    .unionAll( q2 );</code></pre>

          <h1 id="when--conditionals">When / Conditionals</h1>
<p>If you store the builder object in a variable, you can use if and else statements like you would expect.</p>
<pre><code class="language-javascript">var q = query.from( &quot;posts&quot; );
if ( someFlag ) {
    q.orderBy( &quot;published_date&quot;, &quot;desc&quot; );
}</code></pre>
<p>This works, but breaks chainability. To keep chainability you can use the when helper method.</p>
<h2 id="when">when`</h2>
<p>The when helper is used to allow conditional statements when defining queries without using if statements and having to store temporary variables.</p>
<pre><code class="language-javascript">query.from( &quot;posts&quot; )
    .when( someFlag, function( q ) {
        q.orderBy( &quot;published_date&quot;, &quot;desc&quot; );
    } )
    .get();</code></pre>
<p>You can pass a third argument to be called in the else case.</p>
<pre><code class="language-javascript">query.from( &quot;posts&quot; )
    .when(
        someFlag,
        function( q ) {
            q.orderBy( &quot;published_date&quot;, &quot;desc&quot; );
        },
        function( q ) {
            q.orderBy( &quot;modified_date&quot;, &quot;desc&quot; );
        }
    );</code></pre>
<p>`when callbacks are automatically scoped and grouped.  That means that if a where clause is added inside the callback with an OR combinator the clauses will automatically be grouped (have parenthesis put around them.)  You can disable this feature by passing withoutScoping = true to the when callback.</p>
<pre><code class="language-javascript">qb.from( &quot;users&quot; )
    .where( &quot;active&quot;, 1 )
    .when( len( url.q ), function( q ) {
        q.where( &quot;username&quot;, &quot;LIKE&quot;, q &amp; &quot;%&quot; )
            .orWhere( &quot;email&quot;, &quot;LIKE&quot;, q &amp; &quot;%&quot; );
    } );</code></pre>

          <h1 id="wheres">Wheres</h1>
<h2 id="where-methods">Where Methods</h2>
<h3 id="where">where</h3>
<p>Adds a where clause to a query.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .where( &quot;active&quot;, &quot;=&quot;, 1 );</code></pre>
<p>Using the where method will parameterize the value passed.  If you want to constrain a column to another column, use the <a href="wheres.md#wherecolumn">whereColumn</a> method.</p>
<p>You can also pass an <a href="raw-expressions.md">Expression</a> as the value.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .where( &quot;last_logged_in&quot;, &quot;&gt;&quot;, query.raw( &quot;NOW()&quot; ) );</code></pre>
<p>Any of the following operators can be used in a where clause.</p>
<p>When using the &quot;=&quot; constraint, you can use a shortcut and define the value as the second argument.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .where( &quot;active&quot;, 1 );</code></pre>
<p>You may also use <a href="wheres.md#dynamic-where-methods">dynamic where{Column}</a> statements to simplify this further.</p>
<p>To group where statements together, pass a function to the where clause as the only parameter.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .where( function( q ) {
        q.where( &quot;active&quot;, 1 )
            .where( &quot;last_logged_in&quot;, &quot;&gt;&quot;, dateAdd( &quot;ww&quot;, -1, now() ) )
    } );</code></pre>
<p>This grouping can be nested as many levels as you require.</p>
<p>A Function or QueryBuilder can be used as a subselect expression when passed to value.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .where( &quot;email&quot;, &quot;foo&quot; )
    .orWhere( &quot;id&quot;, &quot;=&quot;, function( q ) {
        q.select( q.raw( &quot;MAX(id)&quot; ) )
            .from( &quot;users&quot; )
            .where( &quot;email&quot;, &quot;bar&quot; );
    } );</code></pre>
<h3 id="andwhere">andWhere</h3>
<p>This method is simply an alias for <a href="wheres.md#where">where</a> with the combinator set to &quot;and&quot;.</p>
<h3 id="orwhere">orWhere</h3>
<p>This method is simply an alias for <a href="wheres.md#where">where</a> with the combinator set to &quot;or&quot;.</p>
<h3 id="wherebetween">whereBetween</h3>
<p>Adds a where between clause to the query.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .whereBetween( &quot;id&quot;, 1, 2 );</code></pre>
<p>If a function or QueryBuilder is passed it is used as a subselect expression.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .whereBetween(
        &quot;id&quot;,
        function( q ) {
            q.select( q.raw( &quot;MIN(id)&quot; ) )
                .from( &quot;users&quot; )
                .where( &quot;email&quot;, &quot;bar&quot; );
        },
        builder.newQuery()
            .select( builder.raw( &quot;MAX(id)&quot; ) )
            .from( &quot;users&quot; )
            .where( &quot;email&quot;, &quot;bar&quot; )
    );</code></pre>
<h3 id="wherenotbetween">whereNotBetween</h3>
<p>Adds a where not in clause to the query.  This behaves identically to the <a href="wheres.md#wherebetween">whereBetween</a> method with the negate`flag set to true.  See the documentation for <a href="wheres.md#wherebetween">whereBetween</a> for usage and examples.</p>
<h3 id="wherecolumn">whereColumn</h3>
<p>Adds a where clause to a query that compares two columns.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .whereColumn( &quot;first_name&quot;, &quot;=&quot;, &quot;last_name&quot; );</code></pre>
<p>Just as with where, when using &quot;=&quot; as the operator you can use a shorthand passing the second column in as the operator and leaving the second column null.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .whereColumn( &quot;first_name&quot;, &quot;last_name&quot; );</code></pre>
<p>`Expressions can be passed in place of either column.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .whereColumn( &quot;first_name&quot;, query.raw( &quot;LOWER(first_name)&quot; ) );</code></pre>
<h3 id="whereexists">whereExists</h3>
<p>Adds a where exists clause to the query.</p>
<p>It can be configured with a function.</p>
<pre><code class="language-javascript">query.from( &quot;orders&quot; )
    .whereExists( function( q ) {
        q.select( q.raw( 1 ) )
            .from( &quot;products&quot; )
            .whereColumn( &quot;products.id&quot;, &quot;orders.id&quot; );
    } );</code></pre>
<p>It can also be configured with a QueryBuilder instance.</p>
<pre><code class="language-javascript">var existsQuery = query.newQuery()
    .select( q.raw( 1 ) )
    .from( &quot;products&quot; )
    .whereColumn( &quot;products.id&quot;, &quot;orders.id&quot; );

query.from( &quot;orders&quot; )
    .whereExists( existsQuery );</code></pre>
<h3 id="wherenotexists">whereNotExists</h3>
<p>Adds a where not in clause to the query.  This behaves identically to the <a href="wheres.md#whereexists">whereExists</a> method with the negate`flag set to true.  See the documentation for <a href="wheres.md#whereexists">whereExists</a> for usage and examples.</p>
<h3 id="wherelike">whereLike</h3>
<p>A shortcut for calling <a href="wheres.md#where">where</a> with &quot;like&quot; set as the operator.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .whereLike( &quot;username&quot;, &quot;J%&quot; );</code></pre>
<h3 id="wherein">whereIn</h3>
<p>Adds a where in clause to the query.</p>
<p>The values passed to whereIn can be a single value, a list of values, or an array of values.</p>
<pre><code class="language-javascript">query.from( &quot;orders&quot; )
    .whereIn( &quot;id&quot;, [ 1, 4, 66 ] );</code></pre>
<p>Some database grammars have a hard limit on the number of parameters passed to a SQL statement.  Keep this in mind while writing your queries.</p>
<p>If a list of values is passed in, it is converted to an array of values using a single comma  &quot;,&quot;  delimiter.</p>
<pre><code class="language-javascript">query.from( &quot;orders&quot; )
    .whereIn( &quot;id&quot;, &quot;1,4,66&quot; );</code></pre>
<p>Any value in the list or array can also be passed using a <a href="parameters-and-bindings.md#custom-parameter-types">custom parameter type</a> to have more control over the parameter settings.</p>
<pre><code class="language-javascript">query.from( &quot;orders&quot; )
    .whereIn( &quot;id&quot;, [ 1, 4, { value = &quot;66&quot;, cfsqltype = &quot;CF_SQL_VARCHAR&quot; } ] );</code></pre>
<p>`Expressions can be freely mixed in with other values.</p>
<pre><code class="language-javascript">query.from( &quot;orders&quot; )
    .whereIn( &quot;id&quot;, [ query.raw( &quot;MAX(id)&quot; ), 4, 66 ] );</code></pre>
<p>A function or QueryBuilder instance can be passed to be used as a subquery expression instead of a list of values.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .whereIn( &quot;id&quot;, function( q ) {
        q.select( &quot;id&quot; )
            .from( &quot;users&quot; )
            .where( &quot;age&quot;, &quot;&gt;&quot;, 25 );
    } );</code></pre>
<p>You may find a whereExists method performs better for you than a whereIn with a subquery.</p>
<h3 id="wherenotin">whereNotIn</h3>
<p>Adds a where not in clause to the query.</p>
<h3 id="whereraw">whereRaw</h3>
<p>Shorthand to add a raw SQL statement to the where clauses.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .whereRaw(
        &quot;id = ? OR email = ? OR is_admin = 1&quot;,
        [ 1, &quot;foo&quot; ]
    );</code></pre>
<h3 id="wherenull">whereNull</h3>
<p>Adds a where null clause to the query.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .whereNull( &quot;id&quot; );</code></pre>
<h3 id="wherenotnull">whereNotNull</h3>
<p>Adds a where not in clause to the query.</p>
<h2 id="dynamic-where-methods">Dynamic Where Methods</h2>
<p>qb uses onMissingMethod to provide a few different helpers when working with where... methods.</p>
<h3 id="andwhere-and-orwhere">andWhere... and orWhere...</h3>
<p>Every where... method in qb can be called prefixed with either and or or.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .where( &quot;username&quot;, &quot;like&quot;, &quot;j%&quot; )
    .andWhere( function( q ) {
        q.where( &quot;isSubscribed&quot;, 1 )
            .orWhere( &quot;isOnFreeTrial&quot;, 1 );
     } );</code></pre>
<h3 id="wherecolumn-1">where{Column}</h3>
<p>If you call a method starting with where that does not match an existing qb method, qb will instead call the where method using the rest of the method name as the first column name.  (The rest of the arguments will be shifted to account for this.)  This also applies to andWhere{Column} and orWhere{Column} method signatures.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .whereUsername( &quot;like&quot;, &quot;j%&quot; )
    .whereActive( 1 );</code></pre>

        </div>
      </main>

      <footer class="print-only">
  <a href="https://groupe-sii.github.io/cheat-sheets">groupe-sii.github.io/cheat-sheets</a>
  <a href="http://www.groupe-sii.com">www.groupe-sii.com</a>
  <a href="https://blog.groupe-sii.com">blog.groupe-sii.com</a>
  <img src="../assets/images/logoSII-white.svg">
</footer>



    </div>

    <div class="reverse">
      <header class="print-only">
    <div class="header-center">
        <div class="description-content">
            <div class="title">quick-orm cheat sheet</div>
        </div>
        <div class="logo-container">
            <img src="../assets/images/quick-orm.png" >
        </div>
    </div>
</header>


      <main>
        <div class="column1">
          
        </div>
        <div class="column2">
          
        </div>
      </main>
    </div>

    <script src="../common/lib/highlight.pack.js"></script>
    <script src="../common/script.js"></script>
  </body>
</html>
