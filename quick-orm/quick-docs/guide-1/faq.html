<h1 id="faq">FAQ</h1>
<h2 id="whats-the-difference-between-posts-and-getposts">What&#39;s the difference between `posts()&#39; and `getPosts()`?</h2>
<p><em>Answered by</em> <a href="https://github.com/elpete"><em>Eric Peterson</em></a>__</p>
<p><strong>TLDR:</strong> Calling a relationship method returns a relationship component.  Preceding that call with &#39;get&#39; loads and executes the relationship query.</p>
<p>When you define a relationship you name the function without a &#39;get&#39; in front of it.  When calling a relationship with &#39;get&#39; preceding it, Quick loads the relationship and executes the query.  You are returned either a single entity (or &#39;null&#39;) or an array of entities.</p>
<p>When you call the relationship function you get back an instance of a Quick Relationship component.  This component is configured based on the entity that created it and the attributes configured in the relationship call.  You can think of a relationship component as a super-charged query.  In fact, you can call other Quick and qb methods on the relationship object.  This is one way to restrict the results you get back.</p>
<p>For instance, perhaps you want to retrieve a specific Post by its id.  In this case, you want the Post to be found only if it belongs to the User.  You could add a constraint to a Post query on the foreign key &#39;userId&#39; like so:</p>
<pre><code class="language-javascript">getInstance( &quot;Post&quot; )
    .where( &quot;userId&quot;, prc.loggedInUser.getId() )
    .findOrFail( rc.id );</code></pre>
<p>Another way to write this is by leveraging existing relationships:</p>
<pre><code class="language-javascript">prc.loggedInUser.posts().findOrFail( rc.id );</code></pre>
<p>Let&#39;s disect this.  At first glance it may look like it is just a matter of style and preference. But the power behind the relationship approach is that it encapsulates the logic to define the relationship.  Remember that relationships don&#39;t have to only define foreign keys.  They can define any custom query logic and give a name to it.  They can even build on each other:</p>
<pre><code class="language-javascript">// User.cfc
component extends=&quot;quick.models.BaseEntity&quot; {

    function posts() {
        return hasMany( &quot;Post&quot; );
    }

    function publishedPosts() {
        return this.posts().whereNotNull( &quot;publishedDate&quot; );
    }

}</code></pre>
<p>You see here that we have now named an important concept to our domain - a published post.  Let&#39;s take this one step further and name the query logic on the Post entity itself.</p>
<pre><code class="language-javascript">// Post.cfc
component extends=&quot;quick.models.BaseEntity&quot; {

    function scopePublished( qb ) {
        qb.whereNotNull( &quot;publishedDate&quot; );
    }

}</code></pre>
<pre><code class="language-javascript">// User.cfc
component extends=&quot;quick.models.BaseEntity&quot; {

    function posts() {
        return hasMany( &quot;Post&quot; );
    }

    function publishedPosts() {
        return this.posts().published();
    }

}</code></pre>
<h2 id="when-do-i-use-a-scope-method-and-when-do-i-use-a-normal-method">When do I use a scope method and when do I use a normal method?</h2>
<h2 id="i-keep-getting-a-quickentitynotloaded-exception--what-is-the-difference-between-a-loaded-entity-and-an-unloaded-entity">I keep getting a `QuickEntityNotLoaded&#39; exception.  What is the difference between a loaded entity and an unloaded entity?</h2>
<h2 id="how-can-i-add-a-subselect-field-to-my-entity">How can I add a subselect field to my entity?</h2>
<h2 id="how-can-i-add-a-computed-field-to-my-entity-like-from-a-sql-case-statement">How can I add a computed field to my entity, like from a SQL CASE statement?</h2>
<h2 id="how-can-i-always-add-a-subselect-or-computed-field-to-my-queries">How can I always add a subselect or computed field to my queries?</h2>
