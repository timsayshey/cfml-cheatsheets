<h1 id="retrieving-entities">Retrieving Entities</h1>
<p>Once you have an entity and its associated database table you can start retrieving data from your database.</p>
<p>You can configure your query to retrieve entities using any qb method.  It is highly recommended you become familiar with the <a href="https://qb.ortusbooks.com/">qb documentation.</a></p>
<h2 id="active-record">Active Record</h2>
<p>You start every interaction with Quick with an instance of an entity. The easiest way to do this is using WireBox. &#39;getInstance&#39; is available in all handlers by default. WireBox can easily be injected in to any other class you need using &#39;inject=&quot;wirebox&quot;`.</p>
<p>Quick is backed by qb, a CFML Query Builder. With this in mind, think of retrieving records for your entities like interacting with qb. For example:</p>
<pre><code class="language-javascript">var users = getInstance( &quot;User&quot; ).all();

for ( var user in users ) {
    writeOutput( user.getUsername() );
}</code></pre>
<p>In addition to using &#39;for&#39; you can utilize the &#39;each&#39; function on arrays. For example:</p>
<pre><code class="language-javascript">var users = getInstance( &quot;User&quot; ).all();

prc.users.each( function( user ) {
    writeOutput( user.getUsername() );
});</code></pre>
<p>You can add constraints to the query just the same as you would using qb directly:</p>
<pre><code class="language-javascript">var users = getInstance( &quot;User&quot; )
    .where( &quot;active&quot;, 1 )
    .orderByDesc( &quot;username&quot; )
    .limit( 10 )
    .get();</code></pre>
<p>For more information on what is possible with qb, check out the <a href="https://qb.ortusbooks.com">qb documentation</a>.</p>
<h2 id="quick-service">Quick Service</h2>
<p>A second way to retrieve results is to use a Quick Service. It is similar to a &#39;VirtualEntityService&#39; from cborm.</p>
<p>The easiest way to create a Quick Service is to inject it using the &#39;quickService:&#39; dsl:</p>
<pre><code class="language-javascript">component {

    property name=&quot;userService&quot; inject=&quot;quickService:User&quot;

}</code></pre>
<p>If you have a existing Service, and you would like to extend the quickService, you can extend the quikc.models.BaseService and then call super.init inside of the service init function passing the name of the entity (for example your User Entity) shown below:</p>
<pre><code class="language-javascript">component singleton extends=&quot;quick.models.BaseService&quot; {

    function init(){
        super.init( &quot;User&quot; );
    }

}</code></pre>
<p>Any method you can call on an entity can be called on the service.  A new entity will be used for all calls to a Quick Service.</p>
<pre><code class="language-javascript">var users = userService
    .where( &quot;active&quot;, 1 )
    .orderByDesc( &quot;username&quot; )
    .limit( 10 )
    .get();</code></pre>
<h2 id="aggregates">Aggregates</h2>
<p>Calling qb&#39;s aggregate methods (&#39;count<code>, &#39;max</code>, etc.) will return the appropriate value instead of an entity or collection of entities.</p>
<h3 id="existsorfail">existsOrFail</h3>
<p>Returns true if any entities exist with the configured query. If no entities exist, it throws an EntityNotFound exception.</p>
<pre><code class="language-javascript">var doesUserExist = getInstance( &quot;User&quot; )
    .existsOrFail( rc.userID );</code></pre>
<h2 id="retrieval-methods">Retrieval Methods</h2>
<h3 id="all">all</h3>
<p>Retrieves all the records for an entity. Calling &#39;all&#39; will ignore any non-global constraints on the query.</p>
<pre><code class="language-javascript">var users = getInstance( &quot;User&quot; ).all();</code></pre>
<h3 id="get">get</h3>
<p>Executes the configured query, eager loads any relations, and returns the entities in a new collection.</p>
<pre><code class="language-javascript">var posts = getInstance( &quot;Post&quot; )
    .whereNotNull( &quot;publishedDate&quot; )
    .get();</code></pre>
<h3 id="paginate">paginate</h3>
<p>Executes the configured query, eager loads any relations, and returns the entities in the configured qb pagination struct.</p>
<pre><code class="language-javascript">var posts = getInstance( &quot;Post&quot; )
    .whereNotNull( &quot;publishedDate&quot; )
    .paginate( rc.page, rc.maxrows );</code></pre>
<pre><code class="language-javascript">// default response example
{
    &quot;results&quot;: [ User#1, User#2, ... ],
    &quot;pagination&quot;: {
        &quot;totalPages&quot;: 2,
        &quot;maxRows&quot;: 25,
        &quot;offset&quot;: 0,
        &quot;page&quot;: 1,
        &quot;totalRecords&quot;: 40
    }
}</code></pre>
<h3 id="simplepaginate">simplePaginate</h3>
<p>Executes the configured query, eager loads any relations, and returns the entities in the configured qb simple pagination struct.</p>
<pre><code class="language-javascript">var posts = getInstance( &quot;Post&quot; )
    .whereNotNull( &quot;publishedDate&quot; )
    .simplePaginate( rc.page, rc.maxrows );</code></pre>
<pre><code class="language-javascript">// default response example
{
    &quot;results&quot;: [ User#1, User#2, ... ],
    &quot;pagination&quot;: {
        &quot;hasMore&quot;: true,
        &quot;maxRows&quot;: 25,
        &quot;offset&quot;: 0,
        &quot;page&quot;: 1
    }
}</code></pre>
<h3 id="first">first</h3>
<p>Executes the configured query and returns the first entity found.  If no entity is found, returns &#39;null`.</p>
<pre><code class="language-javascript">var user = getInstance( &quot;User&quot; )
    .where( &quot;username&quot;, rc.username )
    .first();</code></pre>
<h3 id="firstwhere">firstWhere</h3>
<p>Adds a basic where clause to the query and returns the first result.</p>
<pre><code class="language-javascript">var user = getInstance( &quot;User&quot; )
    .firstWhere( &quot;username&quot;, rc.username );</code></pre>
<h3 id="firstorfail">firstOrFail</h3>
<p>Executes the configured query and returns the first entity found.  If no entity is found, then an &#39;EntityNotFound&#39; exception is thrown with the given or default error message.</p>
<pre><code class="language-javascript">var user = getInstance( &quot;User&quot; )
    .where( &quot;username&quot;, rc.username )
    .firstOrFail();</code></pre>
<h3 id="firstornew">firstOrNew</h3>
<p>Finds the first matching record or returns an unloaded new entity.</p>
<pre><code class="language-javascript">var user = getInstance( &quot;User&quot; )
    .firstOrNew( { &quot;username&quot;: rc.username } );</code></pre>
<h3 id="firstorcreate">firstOrCreate</h3>
<p>Finds the first matching record or creates a new entity.</p>
<pre><code class="language-javascript">var user = getInstance( &quot;User&quot; )
    .firstOrCreate( { &quot;username&quot;: rc.username } );</code></pre>
<h3 id="find">find</h3>
<p>Returns the entity with the id value as the primary key. If no record is found, it returns null instead.</p>
<pre><code class="language-javascript">var user = getInstance( &quot;User&quot; )
    .find( rc.userID );</code></pre>
<h3 id="findorfail">findOrFail</h3>
<p>Returns the entity with the id value as the primary key. If no record is found, it throws an &#39;EntityNotFound&#39; exception.</p>
<pre><code class="language-javascript">var user = getInstance( &quot;User&quot; )
    .findOrFail( rc.userID );</code></pre>
<h3 id="findornew">findOrNew</h3>
<p>Returns the entity with the id value as the primary key. If no record is found, it returns a new unloaded entity.</p>
<pre><code class="language-javascript">var user = getInstance( &quot;User&quot; ).findOrNew(
    9999,
      {
              &quot;firstName&quot; : &quot;doesnt&quot;,
              &quot;lastName&quot;  : &quot;exist&quot;
      }
);</code></pre>
<h3 id="findorcreate">findOrCreate</h3>
<p>Returns the entity with the id value as the primary key. If no record is found, it returns a newly created entity.</p>
<pre><code class="language-javascript">var user = getInstance( &quot;User&quot; ).findOrCreate(
    9999,
      {
        &quot;username&quot;  : &quot;doesntexist&quot;,
              &quot;firstName&quot; : &quot;doesnt&quot;,
              &quot;lastName&quot;  : &quot;exist&quot;,
              &quot;password&quot;  : &quot;secret&quot;
      }
);</code></pre>
<h2 id="hydration-methods">Hydration Methods</h2>
<p>Hydration is a term to describe filling an entity with a struct of data and then marking it as loaded, without doing any database queries.  For example, this might be useful when hydrating a user from session data instead of doing a query every request.</p>
<h3 id="hydrate">hydrate</h3>
<p>Hyrdates an entity from a struct of data.  Hydrating an entity fills the entity and then marks it as loaded.</p>
<p>If the entity&#39;s keys are not included in the struct of data, a &#39;MissingHydrationKey&#39; is thrown.</p>
<pre><code class="language-javascript">var user = getInstance( &quot;User&quot; ).hydrate( {
    &quot;id&quot;: 4,
    &quot;username&quot;: &quot;JaneDoe&quot;,
    &quot;email&quot;: &quot;jane@example.com&quot;,
    &quot;password&quot;: &quot;mypass1234&quot;
} );

user.isLoaded(); // true</code></pre>
<h3 id="hydrateall">hydrateAll</h3>
<p>Hydrates a new collection of entities from an array of structs.</p>
<pre><code class="language-javascript">var users = getInstance( &quot;User&quot; ).hydrateAll( [
    {
        &quot;id&quot;: 3,
        &quot;username&quot;: &quot;JohnDoe&quot;,
        &quot;email&quot;: &quot;john@example.com&quot;,
        &quot;password&quot;: &quot;mypass4321&quot;
    },
    {
        &quot;id&quot;: 4,
        &quot;username&quot;: &quot;JaneDoe&quot;,
        &quot;email&quot;: &quot;jane@example.com&quot;,
        &quot;password&quot;: &quot;mypass1234&quot;
    }
] );</code></pre>
<h2 id="custom-collections">Custom Collections</h2>
<p>If you would like collections of entities to be returned as something besides an array, you can override the &#39;newCollection&#39; method.  It receives the array of entities.  You can return any custom collection you desire.</p>
<h3 id="newcollection">newCollection</h3>
<p>Returns a new collection of the given entities. It is expected to override this method in your entity if you need to specify a different collection to return. You can also call this method with no arguments to get an empty collection.</p>
<pre><code class="language-javascript">// Post.cfc
component extends=&quot;quick.models.BaseEntity&quot; accessors=&quot;true&quot; {

    function newCollection( array entities = [] ) {
        return variables._wirebox.getInstance(
            name = &quot;extras.QuickCollection&quot;,
            initArguments = {
                &quot;collection&quot; = arguments.entities
            }
        );
    }

}</code></pre>
