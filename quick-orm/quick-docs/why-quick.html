<h1 id="why-quick">Why Quick?</h1>
<h2 id="coming-from-cfquery-or-queryexecute">Coming from &lt;cfquery&gt; or queryExecute?</h2>
<p>You might be thinking, I don&#39;t need an ORM engine.  I don&#39;t even know what ORM means!  I know SQL backwards and forwards so there&#39;s nothing an ORM can offer me.  Maybe you&#39;ve had experience with other ORM engines, whether CFML-based or not, and the experience was less that ideal.  Why should you consider Quick?</p>
<p>Quick&#39;s ORM philosophy comes down to three main points:</p>
<ol>
<li>Give relevant names to important collections of SQL code. (<a href="guide-1/getting-started/query-scopes-and-subselects.md#what-are-scopes">scopes</a>, <a href="guide-1/relationships/">relationships</a>, etc.)</li>
<li>Make queries easy to compose at runtime to get the exact data you want in the most efficient way (<a href="guide-1/getting-started/query-scopes-and-subselects.md#subselects">subselects</a>, <a href="guide-1/relationships/eager-loading.md">eager loading</a>, etc.)</li>
<li>Get out of your way when you need or want to write barebones SQL.</li>
</ol>
<h2 id="coming-from-hibernate">Coming from Hibernate?</h2>
<p>Quick was built out of lessons learned and persistent challenges in developing complex RDBMS applications using built-in Hibernate ORM in CFML.</p>
<ul>
<li><p>Hibernate ORM error messages often obfuscate the actual cause of the error</p>
<p>because they are provided directly by the Java classes.</p>
</li>
<li><p>Complex CFML Hibernate ORM applications can consume significant memory and</p>
<p>processing resources, making them cost-prohibitive and inefficient when used</p>
<p>in microservices architecture.</p>
</li>
<li><p>Hibernate ORM is tied to the engine releases. This means that updates come</p>
<p>infrequently and may be costly for non-OSS engine users.</p>
</li>
<li><p>Hibernate ORM is built in Java. This limits contributions from CFML</p>
<p>developers who don&#39;t know Java or don&#39;t feel comfortable contributing to a</p>
<p>Java project.</p>
</li>
<li><p>Hibernate ORM doesn&#39;t take advantage of a lot of dynamic- and</p>
<p>meta-programming available in CFML. (Tools like CBORM have helped to bridge</p>
<p>this gap.)</p>
</li>
</ul>
<p>We can do better.</p>
