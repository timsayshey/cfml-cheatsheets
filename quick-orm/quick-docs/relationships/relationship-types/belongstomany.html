<h1 id="belongstomany">belongsToMany</h1>
<p>A &#39;belongsToMany&#39; relationship is a &#39;many-to-many&#39; relationship. For instance, a &#39;User&#39; may have multiple &#39;Permissions&#39; while a &#39;Permission&#39; can belong to multiple &#39;Users`.</p>
<pre><code class="language-javascript">// User.cfc
component extends=&quot;quick.models.BaseEntity&quot; {

    function permissions() {
       return belongsToMany( &quot;Permission&quot; );
    }

}</code></pre>
<pre><code class="language-javascript">// Permission.cfc
component extends=&quot;quick.models.BaseEntity&quot; {

    function users() {
       return belongsToMany( &quot;User&quot; );
    }

}</code></pre>
<p>The first value passed to &#39;belongsToMany&#39; is a WireBox mapping to the related entity.</p>
<p>`belongsToMany&#39; makes some assumptions about your table structure. To support a &#39;many-to-many&#39; relationship, you need a pivot table. This is, at its simplest, a table with each of the foreign keys as columns.</p>
<pre><code class="language-text">permissions_users
- permissionId
- userId</code></pre>
<p>As you can see, Quick uses a convention of combining the entity table names in alphabetical order with an underscore (&#39;_&#39;) to create the new pivot table name. If you want to override this convention, you can do so by passing the desired table name as the second parameter or the &#39;table&#39; parameter.</p>
<pre><code class="language-javascript">// User.cfc
component extends=&quot;quick.models.BaseEntity&quot; {

    function permissions() {
       return belongsToMany( &quot;Permission&quot;, &quot;user_permission_map&quot; );
    }

}</code></pre>
<p>Quick determines the foreign key of the relationship based on the entity name and key values. In this case, the &#39;User&#39; entity is assumed to have a &#39;userId&#39; foreign key and the &#39;Permission&#39; entity a &#39;permissionId&#39; foreign key. You can override this by passing a &#39;foreignKey&#39; in as the third argument and a &#39;relatedKey&#39; as the fourth argument:</p>
<pre><code class="language-javascript">return belongsToMany(
    &quot;Permission&quot;,
    &quot;user_permission_map&quot;,
    &quot;FK_UserId&quot;,
    &quot;FK_PermissionID&quot;
);</code></pre>
<p>Finally, if you are not joining on the primary keys of the current entity or the related entity, you can specify those keys using the last two parameters:</p>
<pre><code class="language-javascript">return belongsToMany(
    &quot;Permission&quot;,
    &quot;user_permission_map&quot;,
    &quot;FK_UserId&quot;,
    &quot;FK_PermissionID&quot;,
    &quot;user_id&quot;,
    &quot;permission_id&quot;
);</code></pre>
<p>The inverse of &#39;belongsToMany&#39; is also &#39;belongsToMany`. The &#39;foreignKey&#39; and &#39;relatedKey&#39; arguments are swapped on the inverse side of the relationship.</p>
<pre><code class="language-javascript">// Permission.cfc
component extends=&quot;quick.models.BaseEntity&quot; {

    function user() {
        belongsToMany( &quot;User&quot;, &quot;user_permission_map&quot;, &quot;FK_PermissionID&quot;, &quot;FK_UserId&quot; );
    }

}</code></pre>
<p>If you find yourself needing to interact with the pivot table (&#39;permissions_users&#39;) in the example above, you can create an intermediate entity, like &#39;UserPermission`. You will still be able to access the end of the relationship chain using the &#39;hasManyThrough&#39; relationship type.</p>
<pre><code class="language-javascript">// User.cfc
component extends=&quot;quick.models.BaseEntity&quot; {

    function userPermissions() {
        return hasMany( &quot;UserPermission&quot; );
    }

    function permissions() {
        return hasManyThrough( &quot;Permission&quot;, &quot;UserPermission&quot; );
    }

}</code></pre>
<h2 id="attach">attach</h2>
<p>Use the &#39;attach&#39; method to relate two &#39;belongsToMany&#39; entities together. &#39;attach&#39; can take a single id, a single entity, or an array of ids or entities (even mixed and matched) to associate.</p>
<pre><code class="language-javascript">var post = getInstance(&quot;Post&quot;).findOrFail(1);

var tag = getInstance(&quot;Tag&quot;).create(&quot;miscellaneous&quot;);

// pass an id
post.tags().attach(tag.getId());
// or pass an entity
post.tags().attach(tag);</code></pre>
<h2 id="detach">detach</h2>
<p>Use the &#39;detach&#39; method to remove an existing entity from a &#39;belongsToMany&#39; relationship. &#39;detatch&#39; can also take a single id, a single entity, or an array of ids or entities (even mixed and matched) to remove.</p>
<pre><code class="language-javascript">var post = getInstance(&quot;Post&quot;).findOrFail(1);

var tag = getInstance(&quot;Tag&quot;).create(&quot;miscellaneous&quot;);

// pass an id
post.tags().detach(tag.getId());
// or pass an entity
post.tags().detach(tag);</code></pre>
<h2 id="sync">sync</h2>
<p>Sometimes you just want the related entities to be a list you give it. For these situations, use the &#39;sync&#39; method.</p>
<pre><code class="language-javascript">var post = getInstance(&quot;Post&quot;).findOrFail(1);

post.tags().sync([2, 3, 6]);</code></pre>
<p>Now, no matter what relationships existed before, this &#39;Post&#39; will only have three tags associated with it.</p>
