<html>
  <head>
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700|Droid+Sans:700" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="../common.css">
    <link rel="stylesheet" href="../common/lib/atom-one-light.css">
    <link rel="stylesheet" href="./query-builder.css">
  </head>
  <body>
    <input type="checkbox" id="showPreview"/>
    <div class="first-side">
      <div class="cutter">
<div class="cut cut-top-left">&nbsp;</div>
<div class="cut cut-bottom-left">&nbsp;</div>
<div class="cut cut-top-right">&nbsp;</div>
<div class="cut cut-bottom-right">&nbsp;</div>
</div>
<header>
    <div class="home-button no-print">
        <a href="../" title="back to home cheat Sheet"><i class="material-icons">home</i></a>
        <label for="showPreview"><i class="material-icons">visibility</i></label>
    </div>
    <div class="header-center">
        <div class="description-content">
            <div class="title">QB Query Builder Cheat Sheet</div>
            <div class="sub-title">Library for Coldfusion / Lucee / CFML</div>
        </div>

        <div class="logo-container">
            <img src="../assets/images/qb.png">
        </div>
    </div>
    <div class="logo-category no-print">
        <i class="material-icons" onclick="printLarge()">print</i>
    </div>
</header>



      <div class="menu">
        <a href="#wheres">Wheres</a>
        <a href="#by-and-having">By And Having</a>
        <a href="#offset-and-pagination">Offset And Pagination</a>
        <a href="#common-table-expressions">Common Table Expressions</a>
        <a href="#from">From</a>
        <a href="#grouping-and-limit">Grouping And Limit</a>
        <a href="#unions">Unions</a>
        <a href="#selects">Selects</a>
        <a href="#when">When</a>
        <a href="#joins">Joins</a>
        <a href="#parameters-and-bindings">Parameters And Bindings</a>
        <a href="#raw-expressions">Raw Expressions</a>
        <a href="#retrieving-results">Retrieving Results</a>
        <a href="#aggregates">Aggregates</a>
        <a href="#inserts-updates-deletes">Inserts Updates Deletes</a>
      </div>
      <br><br>
      <main>
        <div class="column1">
          <a id="wheres"></a>
          <h1 id="wheres">Wheres</h1>
<h2 id="where-methods">Where Methods</h2>
<h3 id="where">where</h3>
<p>Adds a where clause to a query.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .where( &quot;active&quot;, &quot;=&quot;, 1 );</code></pre>
<p>Using the where method will parameterize the value passed.  If you want to constrain a column to another column, use the <a href="https://qb.ortusbooks.com/query-builder/building-queries/wheres#wherecolumn">whereColumn</a> method.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .where( &quot;last_logged_in&quot;, &quot;&gt;&quot;, query.raw( &quot;NOW()&quot; ) );</code></pre>
<p>Any of the following operators can be used in a where clause.</p>
<p>When using the &quot;=&quot; constraint, you can use a shortcut and define the value as the second argument.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .where( &quot;active&quot;, 1 );</code></pre>
<p>You may also use <a href="https://qb.ortusbooks.com/query-builder/building-queries/wheres#dynamic-where-methods">dynamic where{Column}</a> statements to simplify this further.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .where( function( q ) {
        q.where( &quot;active&quot;, 1 )
            .where( &quot;last_logged_in&quot;, &quot;&gt;&quot;, dateAdd( &quot;ww&quot;, -1, now() ) )
    } );</code></pre>
<p>This grouping can be nested as many levels as you require.</p>
<p>A Function or QueryBuilder can be used as a subselect expression when passed to value.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .where( &quot;email&quot;, &quot;foo&quot; )
    .orWhere( &quot;id&quot;, &quot;=&quot;, function( q ) {
        q.select( q.raw( &quot;MAX(id)&quot; ) )
            .from( &quot;users&quot; )
            .where( &quot;email&quot;, &quot;bar&quot; );
    } );</code></pre>
<h3 id="andwhere">andWhere</h3>
<p>This method is simply an alias for <a href="https://qb.ortusbooks.com/query-builder/building-queries/wheres#where">where</a> with the combinator set to &quot;and&quot;.</p>
<h3 id="orwhere">orWhere</h3>
<p>This method is simply an alias for <a href="https://qb.ortusbooks.com/query-builder/building-queries/wheres#where">where</a> with the combinator set to &quot;or&quot;.</p>
<h3 id="wherebetween">whereBetween</h3>
<p>Adds a where between clause to the query.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .whereBetween( &quot;id&quot;, 1, 2 );</code></pre>
<p>If a function or QueryBuilder is passed it is used as a subselect expression.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .whereBetween(
        &quot;id&quot;,
        function( q ) {
            q.select( q.raw( &quot;MIN(id)&quot; ) )
                .from( &quot;users&quot; )
                .where( &quot;email&quot;, &quot;bar&quot; );
        },
        builder.newQuery()
            .select( builder.raw( &quot;MAX(id)&quot; ) )
            .from( &quot;users&quot; )
            .where( &quot;email&quot;, &quot;bar&quot; )
    );</code></pre>
<h3 id="wherenotbetween">whereNotBetween</h3>
<p>Adds a where not in clause to the query.  This behaves identically to the <a href="https://qb.ortusbooks.com/query-builder/building-queries/wheres#wherebetween">whereBetween</a> method with the negate`flag set to true.</p>
<h3 id="wherecolumn">whereColumn</h3>
<p>Adds a where clause to a query that compares two columns.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .whereColumn( &quot;first_name&quot;, &quot;=&quot;, &quot;last_name&quot; );</code></pre>
<p>Just as with where, when using &quot;=&quot; as the operator you can use a shorthand passing the second column in as the operator and leaving the second column null.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .whereColumn( &quot;first_name&quot;, &quot;last_name&quot; );</code></pre>
<p>`Expressions can be passed in place of either column.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .whereColumn( &quot;first_name&quot;, query.raw( &quot;LOWER(first_name)&quot; ) );</code></pre>
<h3 id="whereexists">whereExists</h3>
<p>Adds a where exists clause to the query.</p>
<p>It can be configured with a function.</p>
<pre><code class="language-javascript">query.from( &quot;orders&quot; )
    .whereExists( function( q ) {
        q.select( q.raw( 1 ) )
            .from( &quot;products&quot; )
            .whereColumn( &quot;products.id&quot;, &quot;orders.id&quot; );
    } );</code></pre>
<p>It can also be configured with a QueryBuilder instance.</p>
<pre><code class="language-javascript">var existsQuery = query.newQuery()
    .select( q.raw( 1 ) )
    .from( &quot;products&quot; )
    .whereColumn( &quot;products.id&quot;, &quot;orders.id&quot; );

query.from( &quot;orders&quot; )
    .whereExists( existsQuery );</code></pre>
<h3 id="wherenotexists">whereNotExists</h3>
<p>Adds a where not in clause to the query.  This behaves identically to the <a href="https://qb.ortusbooks.com/query-builder/building-queries/wheres#whereexists">whereExists</a> method with the negate`flag set to true.</p>
<h3 id="wherelike">whereLike</h3>
<p>A shortcut for calling <a href="https://qb.ortusbooks.com/query-builder/building-queries/wheres#where">where</a> with &quot;like&quot; set as the operator.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .whereLike( &quot;username&quot;, &quot;J%&quot; );</code></pre>
<h3 id="wherein">whereIn</h3>
<p>Adds a where in clause to the query.</p>
<p>Pass single value, a list of values, or an array of values.</p>
<pre><code class="language-javascript">query.from( &quot;orders&quot; )
    .whereIn( &quot;id&quot;, [ 1, 4, 66 ] );</code></pre>
<h3 id="wherenotin">whereNotIn</h3>
<p>Adds a where not in clause to the query.</p>
<h3 id="whereraw">whereRaw</h3>
<p>Shorthand to add a raw SQL statement to the where clauses.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .whereRaw(
        &quot;id = ? OR email = ? OR is_admin = 1&quot;,
        [ 1, &quot;foo&quot; ]
    );</code></pre>
<h3 id="wherenull">whereNull</h3>
<p>Adds a where null clause to the query.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .whereNull( &quot;id&quot; );</code></pre>
<h3 id="wherenotnull">whereNotNull</h3>
<p>Adds a where not in clause to the query.</p>
<h2 id="dynamic-where-methods">Dynamic Where Methods</h2>
<p>qb uses onMissingMethod to provide a few different helpers when working with where... methods.</p>
<h3 id="andwhere-and-orwhere">andWhere... and orWhere...</h3>
<p>Every where... method in qb can be called prefixed with either and or or.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .where( &quot;username&quot;, &quot;like&quot;, &quot;j%&quot; )
    .andWhere( function( q ) {
        q.where( &quot;isSubscribed&quot;, 1 )
            .orWhere( &quot;isOnFreeTrial&quot;, 1 );
     } );</code></pre>
<h3 id="wherecolumn-1">where{Column}</h3>
<p>If you call a method starting with where that does not match an existing qb method, qb will instead call the where method using the rest of the method name as the first column name.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .whereUsername( &quot;like&quot;, &quot;j%&quot; )
    .whereActive( 1 );</code></pre>

          <a id="when"></a>
          <h1 id="when--conditionals">When / Conditionals</h1>
<p>If you store the builder object in a variable, you can use if and else statements like you would expect.</p>
<pre><code class="language-javascript">var q = query.from( &quot;posts&quot; );
if ( someFlag ) {
    q.orderBy( &quot;published_date&quot;, &quot;desc&quot; );
}</code></pre>
<p>This works, but breaks chainability. To keep chainability you can use the when helper method.</p>
<h2 id="when">when</h2>
<p>The when helper is used to allow conditional statements when defining queries without using if statements and having to store temporary variables.</p>
<pre><code class="language-javascript">query.from( &quot;posts&quot; )
    .when( someFlag, function( q ) {
        q.orderBy( &quot;published_date&quot;, &quot;desc&quot; );
    } )
    .get();</code></pre>

          <a id="selects"></a>
          <h1 id="selects">Selects</h1>
<h2 id="select">select</h2>
<p>If you pass no columns to this method, it will default to &quot;*&quot;.</p>
<pre><code class="language-javascript">.select( [ &quot;fname AS firstName&quot;, &quot;age&quot; ] ).from( &quot;users&quot; )</code></pre>
<h2 id="distinct">distinct</h2>
<p>Calling distinct will cause the query to be executed with the DISTINCT keyword.</p>
<pre><code class="language-javascript">.select( &quot;username&quot; ).distinct().from( &quot;users&quot; )</code></pre>
<h2 id="addselect">addSelect</h2>
<p>This method adds the columns passed to it to the currently selected columns.</p>
<pre><code class="language-javascript">.addSelect( [ &quot;fname AS firstName&quot;, &quot;age&quot; ] ).from( &quot;users&quot; )</code></pre>
<h2 id="selectraw">selectRaw</h2>
<p>A shortcut to use a raw expression in the select clause.</p>
<pre><code class="language-javascript">.selectRaw( &quot;YEAR(birthdate) AS birth_year&quot; ).from( &quot;users&quot; )</code></pre>
<h2 id="subselect">subSelect</h2>
<p>The subselect is added to the other already selected columns.</p>
<pre><code class="language-javascript">.subSelect( &quot;last_login_date&quot;, ( q ) =&gt; {
  q.selectRaw( &quot;MAX(created_date)&quot; ).from( &quot;logins&quot; )
} ) ).from( &quot;users&quot; )</code></pre>
<h2 id="clearselect">clearSelect</h2>
<p>Clears out the selected columns for a query along with any configured select bindings.</p>
<pre><code class="language-javascript">.from( &quot;users&quot; )
    .select( [ &quot;fname AS firstName&quot;, &quot;age&quot; ] )
    .clearSelect()</code></pre>
<h2 id="reselect">reselect</h2>
<p>Clears out the selected columns for a query along with any configured select bindings.</p>
<pre><code class="language-javascript">.from( &quot;users&quot; )
    .select( [ &quot;fname AS firstName&quot;, &quot;age&quot; ] )
    .reselect( &quot;username&quot; )</code></pre>
<h2 id="reselectraw">reselectRaw</h2>
<p>Clears out the selected columns.</p>
<pre><code class="language-javascript">.from( &quot;users&quot; ).select( [ &quot;fname AS firstName&quot;, &quot;age&quot; ] )
    .reselectRaw( &quot;YEAR(birthdate) AS birth_year&quot; )</code></pre>

          <a id="by-and-having"></a>
          <h1 id="group-by-and-having">Group By and Having</h1>
<h2 id="groupby">groupBy</h2>
<p>Passing a single string will group by that one column.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .groupBy( &quot;country&quot; );</code></pre>
<p>You can also pass a list of column names.  A single comma  &quot;,&quot;  will be used as the delimiter.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .groupBy( &quot;country,city&quot; );</code></pre>
<p>An array of column names can be provided.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .groupBy( [ &quot;country&quot;, &quot;city&quot; ] );</code></pre>
<p>Calling groupBy multiple times will to the current groups.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .groupBy( &quot;country&quot; )
    .groupBy( &quot;city&quot; );</code></pre>
<p>An <a href="https://qb.ortusbooks.com/query-builder/building-queries/raw-expressions.md">Expression</a> can be passed in place of a column.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .groupBy( query.raw( &quot;DATE(created_at)&quot; ) );</code></pre>
<h2 id="having">having</h2>
<p>Adds a having clause to a query.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .groupBy( &quot;email&quot; )
    .having( &quot;email&quot;, &quot;&gt;&quot;, 1 );</code></pre>
<p>`Expressions can be used in place of the column or the value.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .groupBy( &quot;email&quot; )
    .having( query.raw( &quot;COUNT(email)&quot; ), &quot;&gt;&quot;, 1 );</code></pre>

          <a id="offset-and-pagination"></a>
          <h1 id="limit-offset-and-pagination">Limit, Offset, and Pagination</h1>
<h2 id="limit">limit</h2>
<p>Sets the limit value for the query.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .limit( 5 );</code></pre>
<h2 id="take">take</h2>
<p>Sets the limit value for the query.  Alias for <a href="https://qb.ortusbooks.com/query-builder/building-queries/limit-offset-and-pagination#limit">limit</a>.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .take( 5 );</code></pre>
<h2 id="offset">offset</h2>
<p>Sets the offset value for the query.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .offset( 25 );</code></pre>
<h2 id="forpage">forPage</h2>
<p>Helper method to calculate the limit and offset given a page number and count per page.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .forPage( 3, 15 );</code></pre>
<h2 id="simplepaginate--paginate">simplePaginate &amp; paginate</h2>
<p>This method combines forPage, count, and get to create a pagination struct alongside the results. Info on the simplePaginate or paginate methods, including custom pagination collectors, can be found in the <a href="https://qb.ortusbooks.com/query-builder/executing-queries/retrieving-results#paginate">Retreiving Results</a> section of the documentation.</p>

        </div>
        <div class="column2">
          <a id="from"></a>
          <h1 id="from">From</h1>
<h2 id="from-1">from</h2>
<p>Used to set the base table for the query.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; );</code></pre>
<h2 id="table">table</h2>
<p>An alias for from where you like how calling table looks.</p>
<pre><code class="language-javascript">query.table( &quot;users&quot; ).insert( { &quot;name&quot; = &quot;jon&quot; } );</code></pre>
<h2 id="fromraw">fromRaw</h2>
<p>Sometimes you need more control over your from clause in order to add grammar specific instructions, such as adding SQL Server table hints to your queries.</p>
<pre><code class="language-javascript">query.fromRaw( &quot;[users] u (nolock)&quot; ).get();</code></pre>
<h2 id="fromsub">fromSub</h2>
<p>Complex queries often contain derived tables.</p>
<pre><code class="language-javascript">query.select( [ &quot;firstName&quot;, &quot;lastName&quot; ] )
    .fromSub( &quot;legalUsers&quot;, function ( q ) {
        q.select( [ &quot;lName as lastName&quot;, &quot;fName as firstName&quot; ] )
            .from( &quot;users&quot; )
            .where( &quot;age&quot;, &quot;&gt;=&quot;, 21 )
        ;
    } )
    .orderBy( &quot;lastName&quot; )
    .get()</code></pre>

          <a id="grouping-and-limit"></a>
          <h1 id="order-by">Order By</h1>
<p>The orderBy method seems simple but has a lot of depth depending on the type of arguments you pass in.</p>
<p>Calling orderBy multiple times appends to the order list.</p>
<h2 id="order-by-string">Order By (String)</h2>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .orderBy( &quot;email&quot; );</code></pre>
<p>Calling orderBy multiple times will append to the order list.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .orderBy( &quot;email&quot; )
    .orderBy( &quot;username&quot;, &quot;desc&quot; );</code></pre>
<p>You can also provide an <a href="https://qb.ortusbooks.com/query-builder/building-queries/raw-expressions.md">Expression</a>.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .orderBy( query.raw( &quot;DATE(created_at)&quot; ) );</code></pre>
<h2 id="order-by-list">Order By (List)</h2>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .orderBy( &quot;email|asc,username&quot;, &quot;desc&quot; );</code></pre>
<h2 id="order-by-array-of-strings">Order By (Array of Strings)</h2>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .orderBy( [ &quot;email|asc&quot;, &quot;username&quot; ], &quot;desc&quot; );</code></pre>
<h2 id="order-by-array-of-structs">Order By (Array of Structs)</h2>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .orderBy( [
        { &quot;column&quot;: &quot;email&quot;, &quot;direction&quot;: &quot;asc&quot; },
        &quot;username&quot;
    ], &quot;desc&quot; );</code></pre>
<h2 id="order-by-subquery">Order By (Subquery)</h2>
<p>You can order with a subquery using either a function or a QueryBuilder instance.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .orderBy( function( q ) {
        q.selectRaw( &quot;MAX(created_date)&quot; )
            .from( &quot;logins&quot; )
            .whereColumn( &quot;users.id&quot;, &quot;logins.user_id&quot; );
    } );</code></pre>
<h2 id="order-by-raw">Order By Raw</h2>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .orderByRaw( &quot;CASE WHEN status = ? THEN 1 ELSE 0 END DESC&quot;, [ 1 ] );</code></pre>
<h2 id="clearorders">clearOrders</h2>
<p>Clears the currently configured orders for the query.  Usually used by downstream libraries like <a href="https://qb.ortusbooks.com/query-builder/building-queries/https://quick.ortusbooks.com/">Quick</a>.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .orderBy( &quot;email&quot; )
    .clearOrders();</code></pre>
<h2 id="reorder">reorder</h2>
<p>Clears configured orders for query and sets the new orders passed in.  Any valid argument to <a href="https://qb.ortusbooks.com/query-builder/building-queries/ordering-grouping-and-limit.md">orderBy</a> can be passed here.  Usually used by downstream libraries like <a href="https://qb.ortusbooks.com/query-builder/building-queries/https://quick.ortusbooks.com/">Quick</a>.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .orderBy( &quot;email&quot; )
    .reorder( &quot;username&quot; );</code></pre>

          <a id="common-table-expressions"></a>
          <h1 id="common-table-expressions-ie-ctes">Common Table Expressions (i.e. CTEs)</h1>
<p>Common Table Expressions (CTEs) allow you to create re-usable temporal result sets.</p>
<h2 id="with">with</h2>
<p>You can build a CTE using a function:</p>
<pre><code class="language-javascript">// qb
query.with( &quot;UserCTE&quot;, function ( q ) {
        q
            .select( [ &quot;fName as firstName&quot;, &quot;lName as lastName&quot; ] )
            .from( &quot;users&quot; )
            .where( &quot;disabled&quot;, 0 );
    } )
    .from( &quot;UserCTE&quot; )
    .get();</code></pre>
<h2 id="withrecursive">withRecursive</h2>
<pre><code class="language-javascript">query
.withRecursive( &quot;Hierarchy&quot;, function ( q ) {
    q.select( [ &quot;Id&quot;, &quot;ParentId&quot;, &quot;Name&quot;, q.raw( &quot;0 AS [Generation]&quot; ) ] )
        .from( &quot;Sample&quot; )
        .whereNull( &quot;ParentId&quot; )
        // use recursion to join the child rows to their parents
        .unionAll( function ( q ) {
            q.select( [
                    &quot;child.Id&quot;,
                    &quot;child.ParentId&quot;,
                    &quot;child.Name&quot;,
                    q.raw( &quot;[parent].[Generation] + 1&quot; )
                ] )
                .from( &quot;Sample as child&quot; )
                .join( &quot;Hierarchy as parent&quot;, &quot;child.ParentId&quot;, &quot;parent.Id&quot; );
        } );
    }, [ &quot;Id&quot;, &quot;ParentId&quot;, &quot;Name&quot;, &quot;Generation&quot; ] )
    .from( &quot;Hierarchy&quot; )
    .get();</code></pre>

          <a id="unions"></a>
          <h1 id="unions">Unions</h1>
<p>The query builder also lets you create union statements on your queries using either UNION or UNION ALL strategies.</p>
<h2 id="union">union</h2>
<p>Adds a UNION statement to the query.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .select( &quot;name&quot; )
    .where( &quot;id&quot;, 1 )
    .union( function ( q ) {
        q.from( &quot;users&quot; )
            .select( &quot;name&quot; )
            .where( &quot;id&quot;, 2 );
    } );</code></pre>
<h2 id="unionall">unionAll</h2>
<p>Adds a UNION ALL statement to the query.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .select( &quot;name&quot; )
    .where( &quot;id&quot;, 1 )
    .unionAll( function( q ) {
        q.from( &quot;users&quot; )
            .select( &quot;name&quot; )
            .where( &quot;id&quot;, 2 );
     } );</code></pre>

          <a id="joins"></a>
          <h1 id="joins">Joins</h1>
<p>Join clauses range from simple to complex including joining complete subqueries on multiple conditions. qb has your back with all of these use cases.</p>
<h2 id="join">join</h2>
<p>Applies a join to the query. The simplest join is to a table based on two columns:</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .join( &quot;posts&quot;, &quot;users.id&quot;, &quot;=&quot;, &quot;posts.author_id&quot; );</code></pre>
<p>When doing a simple join using = as the operator, you can omit it and pass just the column names:</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .join( &quot;posts&quot;, &quot;users.id&quot;, &quot;posts.author_id&quot; );</code></pre>
<h2 id="joinwhere">joinWhere</h2>
<p>Adds a join to another table based on a WHERE clause instead of an ON clause.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .joinWhere( &quot;contacts&quot;, &quot;contacts.balance&quot;, &quot;&lt;&quot;, 100 );</code></pre>
<p>For complex joins, a function can be passed to first.</p>
<h2 id="joinraw">joinRaw</h2>
<p>Uses the raw SQL provided to as the table for the join clause.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .joinRaw( &quot;posts (nolock)&quot;, &quot;users.id&quot;, &quot;posts.author_id&quot; );</code></pre>
<p>Using joinRaw will most likely tie your code to a specific database</p>
<h2 id="joinsub">joinSub</h2>
<p>Adds a join to a derived table. All the functionality of the join method applies to constrain the query.</p>
<pre><code class="language-javascript">var sub = query.newQuery()
    .select( &quot;id&quot; )
    .from( &quot;contacts&quot; )
    .whereNotIn( &quot;id&quot;, [ 1, 2, 3 ] );
    query.from( &quot;users as u&quot; )
    .joinSub( &quot;c&quot;, sub, &quot;u.id&quot;, &quot;=&quot;, &quot;c.id&quot; );</code></pre>
<h2 id="leftjoin">leftJoin</h2>
<pre><code class="language-javascript">query.from( &quot;posts&quot; )
    .leftJoin( &quot;users&quot;, &quot;users.id&quot;, &quot;posts.author_id&quot; );</code></pre>
<h2 id="leftjoinraw">leftJoinRaw</h2>
<p>Uses the raw SQL provided to as the table for the left join clause. All the other functionality of leftJoinRaw matches the join method.</p>
<pre><code class="language-javascript">query.from( &quot;posts&quot; )
    .leftJoinRaw( &quot;users (nolock)&quot;, &quot;users.id&quot;, &quot;posts.author_id&quot; );</code></pre>
<h2 id="leftjoinsub">leftJoinSub</h2>
<p>Adds a left join to a derived table.</p>
<pre><code class="language-javascript">var sub = query.newQuery()
    .select( &quot;id&quot; )
    .from( &quot;contacts&quot; )
    .whereNotIn( &quot;id&quot;, [ 1, 2, 3 ] );
    query.from( &quot;users as u&quot; )
    .leftJoinSub( &quot;c&quot;, sub, &quot;u.id&quot;, &quot;=&quot;, &quot;c.id&quot; );</code></pre>
<h2 id="rightjoin">rightJoin</h2>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .rightJoin( &quot;posts&quot;, &quot;users.id&quot;, &quot;posts.author_id&quot; );</code></pre>
<h2 id="rightjoinraw">rightJoinRaw</h2>
<p>Uses the raw SQL provided to as the table for the right join clause.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .rightJoinRaw( &quot;posts (nolock)&quot;, &quot;users.id&quot;, &quot;posts.author_id&quot; );</code></pre>
<p>Using rightJoinRaw will most likely tie your code to a specific database.</p>
<h2 id="rightjoinsub">rightJoinSub</h2>
<p>Adds a right join to a derived table.</p>
<pre><code class="language-javascript">var sub = query.newQuery()
    .select( &quot;id&quot; )
    .from( &quot;contacts&quot; )
    .whereNotIn( &quot;id&quot;, [ 1, 2, 3 ] );
    query.from( &quot;users as u&quot; )
    .rightJoinSub( &quot;c&quot;, sub, &quot;u.id&quot;, &quot;=&quot;, &quot;c.id&quot; );</code></pre>
<h2 id="crossjoin">crossJoin</h2>
<pre><code class="language-javascript">query.from( &quot;users&quot; ).crossJoin( &quot;posts&quot; );</code></pre>
<h2 id="crossjoinraw">crossJoinRaw</h2>
<p>Uses the raw SQL provided to as the table for the cross join clause. Cross joins cannot be further constrained with on or where clauses.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; ).crossJoinRaw( &quot;posts (nolock)&quot; );</code></pre>
<h2 id="crossjoinsub">crossJoinSub</h2>
<p>Adds a cross join to a derived table. The derived table can be defined using a QueryBuilder instance or a function just as with <a href="https://qb.ortusbooks.com/query-builder/building-queries/joins#joinsub">joinSub</a>.</p>
<pre><code class="language-javascript">var sub = query.newQuery()
    .select( &quot;id&quot; )
    .from( &quot;contacts&quot; )
    .whereNotIn( &quot;id&quot;, [ 1, 2, 3 ] );
    query.from( &quot;users as u&quot; ).crossJoinSub( &quot;c&quot;, sub );</code></pre>
<h2 id="newjoin">newJoin</h2>
<pre><code class="language-javascript">var j = query.newJoin( &quot;contacts&quot; )
    .on( &quot;users.id&quot;, &quot;posts.author_id&quot; );
    query.from( &quot;users&quot; ).join( j );</code></pre>
<pre><code class="language-javascript">// This is still an inner join because
// the JoinClause is an inner join
var j = query.newJoin( &quot;contacts&quot;, &quot;inner&quot; )
    .on( &quot;users.id&quot;, &quot;posts.author_id&quot; );
    query.from( &quot;users&quot; ).leftJoin( j );</code></pre>
<h2 id="joinclause">JoinClause</h2>
<p>A JoinClause is a specialized version of a QueryBuilder. You may call on or orOn to constrain the JoinClause. You may also call any <a href="https://qb.ortusbooks.com/query-builder/building-queries/wheres.md">where</a> methods.</p>
<h3 id="on">on</h3>
<p>Applies a join condition to the JoinClause. An alias for whereColumn.</p>
<pre><code class="language-javascript">var j = query.newJoin( &quot;contacts&quot; )
    .on( &quot;users.id&quot;, &quot;posts.author_id&quot; );
    query.from( &quot;users&quot; ).join( j );</code></pre>
<h3 id="oron">orOn</h3>
<p>Applies a join condition to the JoinClause using an or combinator. An alias for orWhereColumn.</p>
<pre><code class="language-javascript">var j = query.newJoin( &quot;contacts&quot; )
    .on( &quot;users.id&quot;, &quot;posts.author_id&quot; )
    .orOn( &quot;users.id&quot;, &quot;posts.reviewer_id&quot; );
    query.from( &quot;users&quot; ).join( j );</code></pre>
<h2 id="preventing-duplicate-joins">Preventing Duplicate Joins</h2>
<p>You can optionally configure qb to ignore duplicate joins.</p>
<pre><code class="language-javascript">moduleSettings = {
    &quot;qb&quot;: {
         &quot;preventDuplicateJoins&quot;: true
    }
};</code></pre>

        </div>
        <div class="column2">
          <a id="retrieving-results"></a>
          <h1 id="retrieving-results">Retrieving Results</h1>
<h2 id="get">get</h2>
<p>The get method is the most common method used for retrieving results.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; ).get();</code></pre>
<p>`get can also take a list or array of columns to use as a shortcut.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; ).get( [ &quot;id&quot;, &quot;name&quot; ] );</code></pre>
<h2 id="first">first</h2>
<p>If you just need to retrieve a single row from the database table, you may use the first method.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; ).first();</code></pre>
<h2 id="values">values</h2>
<p>If you don&#39;t even need an entire row, you may extract a single value from each record using the values method.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; ).values( &quot;firstName&quot; );</code></pre>
<pre><code class="language-text">[ &quot;jon&quot;, &quot;jane&quot;, &quot;jill&quot;, ...
]</code></pre>
<h2 id="value">value</h2>
<p>This method is similar to values except it only returns a single, simple value.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; ).value( &quot;firstName&quot; );</code></pre>
<pre><code class="language-text">&quot;jon&quot;</code></pre>
<p>If no records are returned from the query, one of two things will happen.</p>
<h2 id="chunk">chunk</h2>
<p>Large datasets can be broken up and retrieved in chunks.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; ).chunk( 100, function( users ) {
    // Process the users here
    // Returning false from the callback stops processing
} );</code></pre>
<h2 id="paginate">paginate</h2>
<p>Generates a pagination struct along with the results of the executed query.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .paginate();</code></pre>
<pre><code class="language-javascript">{
    &quot;pagination&quot;: {
        &quot;maxRows&quot;: 25,
        &quot;offset&quot;: 0,
        &quot;page&quot;: 1,
        &quot;totalPages&quot;: 2,
        &quot;totalRecords&quot;: 45
    },
    &quot;results&quot;: [ { /* ... */ }, ]
}</code></pre>
<h2 id="simplepaginate">simplePaginate</h2>
<p>Generates a simple pagination struct along with the results of the executed query.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .simplePaginate();</code></pre>
<pre><code class="language-javascript">{
    &quot;pagination&quot;: {
        &quot;maxRows&quot;: 25,
        &quot;offset&quot;: 0,
        &quot;page&quot;: 1,
        &quot;hasMore&quot;: true
    },
    &quot;results&quot;: [ { /* ... */ }, ]
}</code></pre>
<h3 id="custom-pagination-collectors">Custom Pagination Collectors</h3>
<p>A pagination collector is the name given to the struct returned from calling the <a href="retrieving-results.md#paginate">paginate</a> method.</p>
<h4 id="generatewithresults">generateWithResults</h4>
<p>You can set your custom pagination collector either in the constructor using the paginationCollector argument or by calling setPaginationCollector on a query builder instance.</p>

          <a id="inserts-updates-deletes"></a>
          <h1 id="inserts-updates-and-deletes">Inserts, Updates, and Deletes</h1>
<h2 id="insert">insert</h2>
<p>This call must come after setting the query&#39;s table using <a href="../building-queries/from.md#get">from</a> or <a href="../building-queries/from.md#get-1">table</a>.</p>
<p>You can insert a single record by passing a struct:</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .insert( {
        &quot;name&quot; = &quot;Robert&quot;,
        &quot;email&quot; = &quot;robert@test.com&quot;,
        &quot;age&quot; = 55
    } );</code></pre>
<p>You can specify any <a href="../building-queries/parameters-and-bindings.md#custom-parameter-types">query param</a>.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .insert( {
        &quot;name&quot; = &quot;Robert&quot;,
        &quot;email&quot; = &quot;robert@test.com&quot;,
        &quot;age&quot; = { value = 55, cfsqltype = &quot;CF_SQL_INTEGER&quot; }
    } );</code></pre>
<p>Raw values can be supplied to an insert statement.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .insert( {
        &quot;name&quot; = &quot;Robert&quot;,
        &quot;email&quot; = &quot;robert@test.com&quot;,
        &quot;updatedDate&quot; = query.raw( &quot;NOW()&quot; )
    } );</code></pre>
<p>Multiple rows can be inserted in a batch by passing an array of structs to insert.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; ).insert( [
    { &quot;email&quot; = &quot;john@example.com&quot;, &quot;name&quot; = &quot;John Doe&quot; },
    { &quot;email&quot; = &quot;jane@example.com&quot;, &quot;name&quot; = &quot;Jane Doe&quot; }
] );</code></pre>
<h2 id="returning">returning</h2>
<p>Returning is only supported in PostgresGrammar and SqlServerGrammar.</p>
<p>Specifies columns to be returned from the insert query.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .returning( &quot;id&quot; )
    .insert( {
        &quot;email&quot; = &quot;foo&quot;,
        &quot;name&quot; = &quot;bar&quot;
    } );</code></pre>
<h2 id="update">update</h2>
<p>This call must come after setting the query&#39;s table using <a href="../building-queries/from.md#get">from</a> or <a href="../building-queries/from.md#get-1">table</a>.</p>
<p>Updates a table with a struct of column and value pairs.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .update( {
        &quot;email&quot; = &quot;foo&quot;,
        &quot;name&quot; = &quot;bar&quot;
    } );</code></pre>
<p>You can specify any <a href="../building-queries/parameters-and-bindings.md#custom-parameter-types">query param</a></p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .update( {
        &quot;email&quot; = &quot;foo&quot;,
        &quot;name&quot; = &quot;bar&quot;,
        &quot;updatedDate&quot; = { value = now(), cfsqltype = &quot;CF_SQL_TIMESTAMP&quot; }
    } );</code></pre>
<p>Any constraining of the update query should be done using the appropriate <a href="../building-queries/wheres.md">WHERE</a> statement before calling update.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .whereId( 1 )
    .update( {
        &quot;email&quot; = &quot;foo&quot;,
        &quot;name&quot; = &quot;bar&quot;
    } );</code></pre>
<p>You can update a column based on another column using a raw expression.</p>
<pre><code class="language-javascript">query.from( &quot;hits&quot; )
    .where( &quot;page&quot;, &quot;someUrl&quot; )
    .update( {
        &quot;count&quot; = query.raw( &quot;count + 1&quot; )
    } );</code></pre>
<h3 id="updating-null-values">Updating Null values</h3>
<p>Null values can be inserted by using queryparam syntax:</p>
<p>if you are using Lucee with full null support the following (easier) syntax is also allowed:</p>
<h2 id="addupdate">addUpdate</h2>
<p>Adds values to a later <a href="inserts-updates-deletes.md#update">update</a>, similar to <a href="../building-queries/selects.md#get-2">addSelect</a>.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .whereId( 1 )
    .addUpdate( {
        &quot;email&quot; = &quot;foo&quot;,
        &quot;name&quot; = &quot;bar&quot;
    } )
    .when( true, function( q ) {
        q.addUpdate( {
            &quot;foo&quot;: &quot;yes&quot;
        } );
    } )
    .when( false, function( q ) {
        q.addUpdate( {
            &quot;bar&quot;: &quot;no&quot;
        } );
    } )
    .update();</code></pre>
<h2 id="updateorinsert">updateOrInsert</h2>
<p>Performs an update statement if the configured query returns true for exists.  Otherwise, performs an insert statement.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .where( &quot;email&quot;, &quot;foo&quot; )
    .updateOrInsert( {
        &quot;email&quot; = &quot;foo&quot;,
        &quot;name&quot; = &quot;baz&quot;
    } );</code></pre>
<p>If the configured query returns 0 records, then an insert statement is performed.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .where( &quot;email&quot;, &quot;foo&quot; )
    .updateOrInsert( {
        &quot;email&quot; = &quot;foo&quot;,
        &quot;name&quot; = &quot;baz&quot;
    } );</code></pre>
<h2 id="delete">delete</h2>
<p>Deletes all records that the query returns.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .where( &quot;email&quot;, &quot;foo&quot; )
    .delete();</code></pre>
<p>The id argument is a convenience to delete a single record by id.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .delete( 1 );</code></pre>

          <a id="aggregates"></a>
          <h1 id="aggregates">Aggregates</h1>
<p>The query builder also provides a variety of aggregate methods such as count, max, min, and sum.</p>
<h2 id="exists">exists</h2>
<p>Returns true if the query returns any rows.  Returns false otherwise.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; ).where( &quot;username&quot;, &quot;like&quot;, &quot;jon%&quot; ).exists();</code></pre>
<h2 id="count">count</h2>
<p>Returns an integer number of rows returned by the query.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; ).count();</code></pre>
<h2 id="max">max</h2>
<p>Returns the maximum value for the given column.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; ).max( &quot;age&quot; );</code></pre>
<h2 id="min">min</h2>
<p>Returns the minimum value for the given column.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; ).min( &quot;age&quot; );</code></pre>
<h2 id="sum">sum</h2>
<p>Returns the sum of all returned rows for the given column.</p>
<pre><code class="language-javascript">query.from( &quot;employees&quot; ).sum( &quot;salary&quot; );</code></pre>

          <a id="parameters-and-bindings"></a>
          <h1 id="query-parameters-and-bindings">Query Parameters and Bindings</h1>
<h2 id="custom-parameter-types">Custom Parameter Types</h2>
<p>When passing a parameter to qb, it will infer the sql type to be used.  You can pass a struct with the parameters you would pass to <a href="https://qb.ortusbooks.com/query-builder/building-queries/https://cfdocs.org/cfqueryparam">cfqueryparam</a>.</p>
<p>You can pass include any parameters you would use with <a href="https://qb.ortusbooks.com/query-builder/building-queries/https://cfdocs.org/cfqueryparam">cfqueryparam</a> including null, list, etc.  This applies anywhere parameters are used including where, update, and insert methods.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .where( &quot;id&quot;, &quot;=&quot;, { value = 18, cfsqltype = &quot;CF_SQL_VARCHAR&quot; } );</code></pre>
<p>This can be used when inserting or updating records as well.</p>
<pre><code class="language-javascript">query.table( &quot;users&quot; )
    .insert( {
        &quot;id&quot; = { value 1, cfsqltype = &quot;CF_SQL_VARCHAR&quot; },
        &quot;age&quot; = 18,
        &quot;updatedDate&quot; = { value = now(), cfsqltype = &quot;CF_SQL_DATE&quot; }
    } );</code></pre>
<h3 id="strict-date-detection">Strict Date Detection</h3>
<p>By default, qb will try to determine if a variable is a date using the built-in isDate function.</p>
<pre><code class="language-javascript">moduleSettings = {
    &quot;qb&quot;: {
        &quot;strictDateDetection&quot;: true
    }
};</code></pre>
<h3 id="numeric-sql-type">Numeric SQL Type</h3>
<p>By default, qb will use the CF_SQL_NUMERIC SQL type when it detects a numeric binding.</p>
<pre><code class="language-javascript">moduleSettings = {
    &quot;qb&quot;: {
        &quot;numericSQLType&quot;: &quot;CF_SQL_INTEGER&quot;
    }
};</code></pre>
<h2 id="bindings">Bindings</h2>
<p>Bindings are the values that will be sent as parameters to a prepared SQL statement.</p>
<h3 id="getbindings">getBindings</h3>
<p>This method returns the current bindings in order to be used for the query.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .join( &quot;logins&quot;, function( j ) {
        j.on( &quot;users.id&quot;, &quot;logins.user_id&quot; );
        j.where( &quot;logins.created_date&quot;, &quot;&gt;&quot;, dateAdd( &quot;m&quot;, -1, &quot;01 Jun 2019&quot; ) );
    } )
    .where( &quot;active&quot;, 1 );</code></pre>
<p>You can also retrieve the bindings associated to their corresponding types.</p>
<h3 id="getrawbindings">getRawBindings</h3>
<p>This method returns the current bindings  to be used for the query associated to their corresponding types.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; )
    .join( &quot;logins&quot;, function( j ) {
        j.on( &quot;users.id&quot;, &quot;logins.user_id&quot; );
        j.where( &quot;logins.created_date&quot;, &quot;&gt;&quot;, dateAdd( &quot;m&quot;, -1, &quot;01 Jun 2019&quot; ) );
    } )
    .where( &quot;active&quot;, 1 );</code></pre>

          <a id="raw-expressions"></a>
          <h1 id="raw-expressions">Raw Expressions</h1>
<p>Raw expressions are the qb escape hatch.</p>
<h2 id="raw">raw</h2>
<p>The sql snippet passed to raw is not processed by qb at all.</p>
<pre><code class="language-javascript">query.from( &quot;users&quot; ).select( query.raw( &quot;MAX(created_date)&quot; ) );</code></pre>

        </div>
      </main>


    </div>

    <div class="reverse">
      <header class="print-only">
    <div class="header-center">
        <div class="description-content">
            <div class="title"> query-builder cheat sheet</div>
        </div>
        <div class="logo-container">
            <img src="../assets/images/query-builder.png" >
        </div>
    </div>
</header>


      <main>
        <div class="column1">
          
        </div>
        <div class="column2">
          
        </div>
      </main>
    </div>

    <script src="../common/lib/highlight.pack.js"></script>
    <script src="../common/script.js"></script>
  </body>
</html>
